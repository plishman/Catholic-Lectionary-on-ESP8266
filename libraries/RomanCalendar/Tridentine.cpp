#include "Tridentine.h"
//#include "TimeLib.h"
//#include "Csv.h"

//extern "C" {
//	#include "user_interface.h" // for system_get_free_heap_size
//}

#ifdef _WIN32
	const char* system_get_free_heap_size() { return "system_get_free_heap_size() called"; }
	#include "Bidi.h"
#else
	extern "C" {
		#include "user_interface.h" // for system_get_free_heap_size
	}
#endif

/*
"""The movable feasts of the liturgical calendar.

These feasts are represented as objects with a `name` and a `date`.  The `name`
attribute links the feast to the other data in `movable_feasts_ferias_et_al.json`.

This module contains the function `get_movable_feasts` which will introspect this module
to find all the movable feasts in the calendar.  Any `MovableFeast` objects added to
this module will therefore be added to the calendor generated by `tridentine_calendar`.

"""
*/
/*
import calendar
import datetime as dt
import functools
from abc import ABCMeta
from abc import abstractmethod
*/

const char Tridentine::s_00[] PROGMEM = "-";
const char Tridentine::s_01[] PROGMEM = "gaudete_sunday";
const char Tridentine::s_02[] PROGMEM = "advent_embertide1";
const char Tridentine::s_03[] PROGMEM = "advent_embertide2";
const char Tridentine::s_04[] PROGMEM = "advent_embertide3";
const char Tridentine::s_05[] PROGMEM = "sunday_in_xmas_octave";
const char Tridentine::s_06[] PROGMEM = "holy_name";
const char Tridentine::s_07[] PROGMEM = "holy_family";
const char Tridentine::s_08[] PROGMEM = "plough_monday";
const char Tridentine::s_09[] PROGMEM = "ash_wednesday";
const char Tridentine::s_10[] PROGMEM = "lenten_embertide1";
const char Tridentine::s_11[] PROGMEM = "lenten_embertide2";
const char Tridentine::s_12[] PROGMEM = "lenten_embertide3";
const char Tridentine::s_13[] PROGMEM = "quinquagesima";
const char Tridentine::s_14[] PROGMEM = "fat_thursday"; 
const char Tridentine::s_15[] PROGMEM = "shrove_monday";
const char Tridentine::s_16[] PROGMEM = "mardigras"; 
const char Tridentine::s_17[] PROGMEM = "sexagesima";
const char Tridentine::s_18[] PROGMEM = "septuagesima";
const char Tridentine::s_19[] PROGMEM = "st_matthias";
const char Tridentine::s_20[] PROGMEM = "st_gabriel_of_our_lady_of_sorrows";
const char Tridentine::s_21[] PROGMEM = "laetare_sunday";
const char Tridentine::s_22[] PROGMEM = "passion_sunday";
const char Tridentine::s_23[] PROGMEM = "seven_sorrows";
const char Tridentine::s_24[] PROGMEM = "ladyday";
const char Tridentine::s_25[] PROGMEM = "stjoseph";
const char Tridentine::s_26[] PROGMEM = "palm_sunday";
const char Tridentine::s_27[] PROGMEM = "monday_of_holyweek";
const char Tridentine::s_28[] PROGMEM = "tuesday_of_holyweek";
const char Tridentine::s_29[] PROGMEM = "spy_wednesday";
const char Tridentine::s_30[] PROGMEM = "maundy_thursday";
const char Tridentine::s_31[] PROGMEM = "good_friday";
const char Tridentine::s_32[] PROGMEM = "holy_saturday";
const char Tridentine::s_33[] PROGMEM = "easter";
const char Tridentine::s_34[] PROGMEM = "easter_monday";
const char Tridentine::s_35[] PROGMEM = "easter_tuesday";
const char Tridentine::s_36[] PROGMEM = "easter_wednesday"; 
const char Tridentine::s_37[] PROGMEM = "easter_thursday";
const char Tridentine::s_38[] PROGMEM = "easter_friday";
const char Tridentine::s_39[] PROGMEM = "easter_saturday";
const char Tridentine::s_40[] PROGMEM = "quasimodo_sunday"; 
const char Tridentine::s_41[] PROGMEM = "misericordia_sunday";
const char Tridentine::s_42[] PROGMEM = "jubilate_sunday";
const char Tridentine::s_43[] PROGMEM = "cantate_sunday";
const char Tridentine::s_44[] PROGMEM = "major_rogation";
const char Tridentine::s_45[] PROGMEM = "minor_rogation1";
const char Tridentine::s_46[] PROGMEM = "minor_rogation2";
const char Tridentine::s_47[] PROGMEM = "minor_rogation3";
const char Tridentine::s_48[] PROGMEM = "ascension_vigil";
const char Tridentine::s_49[] PROGMEM = "ascension";
const char Tridentine::s_50[] PROGMEM = "sunday_after_ascension";
const char Tridentine::s_51[] PROGMEM = "pentecost_vigil";
const char Tridentine::s_52[] PROGMEM = "pentecost"; 
const char Tridentine::s_53[] PROGMEM = "pentecost_monday";
const char Tridentine::s_54[] PROGMEM = "pentecost_tuesday";
const char Tridentine::s_55[] PROGMEM = "whit_embertide1";
const char Tridentine::s_56[] PROGMEM = "whit_embertide2";
const char Tridentine::s_57[] PROGMEM = "whit_embertide3";
const char Tridentine::s_58[] PROGMEM = "thursday_in_pentecost_week";
const char Tridentine::s_59[] PROGMEM = "trinity_sunday";
const char Tridentine::s_60[] PROGMEM = "corpus_christi";
const char Tridentine::s_61[] PROGMEM = "sacred_heart";
const char Tridentine::s_62[] PROGMEM = "peters_pence";
const char Tridentine::s_63[] PROGMEM = "michaelmas_embertide1";
const char Tridentine::s_64[] PROGMEM = "michaelmas_embertide2";
const char Tridentine::s_65[] PROGMEM = "michaelmas_embertide3";
const char Tridentine::s_66[] PROGMEM = "all_souls";
const char Tridentine::s_67[] PROGMEM = "christ_king";

const char* const Tridentine::Feasts[68] PROGMEM = {s_00, s_01, s_02, s_03, s_04, s_05, s_06, s_07, s_08, s_09,
                                        s_10, s_11, s_12, s_13, s_14, s_15, s_16, s_17, s_18, s_19,
                                        s_20, s_21, s_22, s_23, s_24, s_25, s_26, s_27, s_28, s_29,
                                        s_30, s_31, s_32, s_33, s_34, s_35, s_36, s_37, s_38, s_39,
                                        s_40, s_41, s_42, s_43, s_44, s_45, s_46, s_47, s_48, s_49,
                                        s_50, s_51, s_52, s_53, s_54, s_55, s_56, s_57, s_58, s_59,
                                        s_60, s_61, s_62, s_63, s_64, s_65, s_66, s_67
                                       };

const char Tridentine::s_mon[] PROGMEM = "Monday"; 
const char Tridentine::s_tue[] PROGMEM = "Tuesday"; 
const char Tridentine::s_wed[] PROGMEM = "Wednesday"; 
const char Tridentine::s_thu[] PROGMEM = "Thursday"; 
const char Tridentine::s_fri[] PROGMEM = "Friday"; 
const char Tridentine::s_sat[] PROGMEM = "Saturday"; 
const char Tridentine::s_sun[] PROGMEM = "Sunday";

const char* const Tridentine::WeekDays[7] PROGMEM = {s_mon, s_tue, s_wed, s_thu, s_fri, s_sat, s_sun}; // Days of week in Python order, ie Mon=0, Sun=6

time64_t Tridentine::date(int day, int month, int year) {
	::tmElements_t ts;						// for arduino
	ts.Second = 0;							/* seconds,  range 0 to 59          */
	ts.Minute = 0;							/* minutes, range 0 to 59           */
	ts.Hour = 0;							/* hours, range 0 to 23             */
	ts.Day = day;							/* day of the month, range 1 to 31  */
	ts.Month = month;						/* month, range 1 to 12             */
	ts.Year = year - BEGIN_EPOCH;			/* The number of years since 1970   */

	return ::makeTime(ts);
}

int Tridentine::date_difference(time64_t date1, time64_t date2) {
	return (int)(date2 - date1);
}

void Tridentine::print_date(time64_t datetime) {
	::tmElements_t ts;						// for arduino
	::breakTime(datetime, ts);

	int d = ts.Day;
	int m = ts.Month;
	int y = ts.Year + BEGIN_EPOCH;

	DEBUG_PRT.printf("[%2d/%2d/%4d]\t", d, m, y);
}

int Tridentine::year(time64_t date) {
//#ifndef __AVR__
//	struct tm* ts = gmtime(&date);
//	return ts->tm_year + BEGIN_EPOCH;
//#else
	return ::year(date); // for arduino
//#endif
}

int Tridentine::liturgical_year(time64_t datetime) {
	int _year = ::year(datetime);
	if (datetime >= first_advent_sunday(_year) && datetime < date(1, 1, ::year(first_advent_sunday(_year)) + 1)) {
		return _year + 1;
	}

	return _year;
}

bool Tridentine::isleap(int year) {
	return (((year) > 0) && !((year) % 4) && (((year) % 100) || !((year) % 400)));
}

bool Tridentine::issameday(time64_t date1, time64_t date2) {
	::tmElements_t ts;						// for arduino
	::breakTime(date1, ts);

	int d1 = ts.Day;
	int m1 = ts.Month;
	int y1 = ts.Year;

	::breakTime(date2, ts);
	if (ts.Day == d1 && ts.Month == m1 && ts.Year == y1) return true;

	return false;
}

time64_t Tridentine::weekday_after(int weekdayAfter, time64_t date) {
	if (weekdayAfter < 0 || weekdayAfter > 6) return (time64_t)-1;

	::tmElements_t ts;						// for arduino
	::breakTime(date, ts);
	int currentWeekday = ts.Wday - 1;

	int daysAfter = DAYS_PER_WEEK; // if the date is exactly one week later

	if (currentWeekday != weekdayAfter) { // otherwise (will be true in most cases)
		daysAfter = weekdayAfter - currentWeekday;
		if (daysAfter < 0) daysAfter += DAYS_PER_WEEK;
	}

	time64_t outputDate = date + (daysAfter * SECS_PER_DAY);  // add number of days (in seconds) from date
	return outputDate;
	// bug: when crossing dst, may be ahead or behind by one hour - will not affect actual date.
}

bool Tridentine::sunday(time64_t date) { 
	bool bResult = (weekday(date) == PY_SUN);
	return bResult;
}

time64_t Tridentine::sunday_after(time64_t date) { return weekday_after(0, date); }

int Tridentine::dayofmonth(time64_t date) {
	::tmElements_t ts;						// for arduino
	::breakTime(date, ts);
	return ts.Day;
}

int Tridentine::monthofyear(time64_t date) {
	::tmElements_t ts;						// for arduino
	::breakTime(date, ts);
	return ts.Month;
}

bool Tridentine::firstday(uint8_t day, time64_t datetime) {
	// day is PY_MON .. PY_SUN. Returns true if day is the first one in the month

	if ((weekday(datetime) == day) && (dayofmonth(datetime) <= 7)) {
		return true;
	}

	return false;
}

time64_t Tridentine::start_date(int year) {
	return first_advent_sunday(year);
}

time64_t Tridentine::end_date(int year) {
	return first_advent_sunday(year + 1) - SECS_PER_DAY;
}

time64_t Tridentine::first_advent_sunday(int year) {
	return sunday_before(nativity(year)) - (3 * DAYS_PER_WEEK * SECS_PER_DAY);
}

time64_t Tridentine::nativity(int year) {
	return date(25, 12, year);
}

time64_t Tridentine::ImmaculateConception(int year) {
	return date(8, 12, year);
}

bool Tridentine::IsImmaculateConception(time64_t datetime) {
	return issameday(ImmaculateConception(year(datetime)), datetime);
}

time64_t Tridentine::NativityStJohnBaptist(int year) {
	return date(24, 6, year);
}

time64_t Tridentine::MartyrdomOfSSPeterAndPaul(int year) {
	return date(29, 6, year);
}

time64_t Tridentine::AssumptionOfMary(int year) {
	return date(15, 8, year);
}

time64_t Tridentine::AllSaints(int year) {
	return date(1, 11, year);
}

time64_t Tridentine::StStephen(int year) {
	return date(3, 8, year);
}

time64_t Tridentine::StStephenProtomartyr(int year) {
	return date(26, 12, year);
}

time64_t Tridentine::StJohnApostle(int year) {
	return date(27, 12, year);
}

time64_t Tridentine::HolyInnocents(int year) {
	return date(28, 12, year);
}

time64_t Tridentine::StLawrence(int year) {
	return date(10, 8, year);
}

time64_t Tridentine::NativityOfMary(int year) {
	return date(8, 9, year);
}

time64_t Tridentine::NativityOfJohnBaptist(int year) {
	return date(24, 6, year);
}

time64_t Tridentine::StJosephSponsi(int year) {
	time64_t st_joseph_sponsi = Easter(year) + 17 * SECS_PER_DAY;

	if (Tridentine::mass_type != MASS_DIVINEAFFLATU) {
		st_joseph_sponsi += SECS_PER_YEAR;	// make it so it can't possibly match (Feast is not in other Masses)
	}
	
	return st_joseph_sponsi;
}

time64_t Tridentine::FindingOfTheHolyCross(int year) {
	return date(3, 5, year);
}

time64_t Tridentine::StJoachimFatherOfMary(int year) {
	return date(16, 8, year);
}

time64_t Tridentine::StAnneMotherOfMary(int year) {
	return date(26, 7, year);
}

time64_t Tridentine::Annunciation(int year) {
	return date(25, 3, year);
}

time64_t Tridentine::StMichaelArchangelDedication(int year) {
	return date(29, 9, year);
}

time64_t Tridentine::CircumcisionOfTheLord(int year) {
	return date(1, 1, year);
}

time64_t Tridentine::BaptismOfTheLord(int year) {
	return date(13, 1, year);
}

time64_t Tridentine::PurificationOfMary(int year) {
	return date(2, 2, year);
}

time64_t Tridentine::PreciousBloodOfJesus(int year) {
	return date(1, 7, year);
}

time64_t Tridentine::VisitationOfMary(int year) {
	return date(2, 7, year);
}

time64_t Tridentine::TransfigurationOfTheLord(int year) {
	return date(6, 8, year);
}

time64_t Tridentine::HolyCross(int year) {
	return date(14, 9, year);
}

time64_t Tridentine::DedicationOfTheLateranBasilica(int year) {
	return date(9, 11, year);
}

time64_t Tridentine::StJosephOpificis(int year) {
	return date(1, 5, year);
}

bool Tridentine::IsAlsoFeastOfTheLord(time64_t datetime) {
	int y = year(datetime);

	return (issameday(datetime, PurificationOfMary(y)) 
		|| issameday(datetime, TransfigurationOfTheLord(y))
		/*|| issameday(datetime, SacredHeart(y))*/ // discovered gaslighted? 05-10-2024 (some feasts of the Lord now missing, added back SacredHeart)
		|| issameday(datetime, HolyCross(y)));	
}

// NB. This is becuase the feasts in the weeks of Pentecost (which move with the date of Pentecost each year), are stored in such as wy that they are opened
// as seasonal, rather than feast days. This helper function will allow the Precedence module to determine if this seasonal day should be treated as a feast.
bool Tridentine::IsMoveableFeastOfTheLordInWeeksAfterPentecost(time64_t datetime) {
	int y = year(datetime);

	return (issameday(datetime, SacredHeart(y))
		|| issameday(datetime, CorpusChristi(y))
		|| issameday(datetime, ChristTheKing(y)));
}

time64_t Tridentine::SSPhilipAndJames(int year) {
	return date(1, 5, year);
}

time64_t Tridentine::StJames(int year) {
	return date(25, 7, year);
}

time64_t Tridentine::StBartholomew(int year) {
	return date(24, 8, year);
}

time64_t Tridentine::StMatthew(int year) {
	return date(21, 9, year);
}

time64_t Tridentine::SSSimonAndJude(int year) {
	return date(28, 10, year);
}

time64_t Tridentine::StAndrew(int year) {
	return date(30, 11, year);
}

time64_t Tridentine::StThomas(int year) {
	return date(21, 12, year);
}

time64_t Tridentine::weekday_before(int weekdayBefore, time64_t datetime) {
	if (weekdayBefore < 0 || weekdayBefore > 6) return (time64_t)-1;

	::tmElements_t ts;						
	::breakTime(datetime, ts);
	int currentWeekday = ts.Wday - 1;

	int daysBefore = DAYS_PER_WEEK; // if the date is exactly one week ago

	if (currentWeekday != weekdayBefore) { // otherwise (will be true in most cases)
		daysBefore = currentWeekday - weekdayBefore;
		if (daysBefore < 0) daysBefore += DAYS_PER_WEEK;
	}

	time64_t outputDate = datetime - (daysBefore * SECS_PER_DAY); // subtract number of days (in seconds) from date

												   /*
												   char inDateStr[100];
												   char outDateStr[100];
												   sprintf(inDateStr, "%s", ctime(&date));
												   sprintf(outDateStr,"%s", ctime(&outputDate));
												   printf("Output: the %s before %s is %s\n", DAYS_OF_WEEK[weekdayBefore], inDateStr, outDateStr);
												   */

	return outputDate;

	// bug: when crossing dst, may be ahead or behind by one hour - will not affect actual date.
}

time64_t Tridentine::sunday_before(time64_t date) { return weekday_before(0, date); }

int Tridentine::weekday(time64_t date, bool bUsePythonWeekdayFormat) {
	// Arduino time library ts.Wday 1=sun .. 7=sat
	// Python date library weekday 0=mon .. 6=sun
	// This function returns a python compatible number for weekday
	::tmElements_t ts;		
	::breakTime(date, ts);
	if (bUsePythonWeekdayFormat) {
		//int8_t Wday = (ts.Wday - 2) % 7;
		return (ts.Wday + 5) % 7;	// return python weekday
	}
	else {
		return ts.Wday - 1;
	}
}

//@functools.lru_cache()
//def computus(year):
time64_t Tridentine::computus(int year) {
	/*
    """Calculate the date of Easter.

    Args:
        year: Integer with the year.

    Returns:
        A `datetime.Date` object with the date of Easter.

    """
*/
/*
	int a = year % 19;
    int b = year; // 100
    int c = year % 100;
    int d = b; // 4
    int e = b % 4;
    int f = (b + 8); // 25
    int g = (b - f + 1); // 3
    int h = (19 * a + b - d - g + 15) % 30;
    int i = c; // 4
    int k = c % 4;
    int m = (32 + 2 * e + 2 * i - h - k) % 7;
    int n = (a + 11 * h + 22 * m); // 451
    int month = (h + m - 7 * n + 114); // 31
    int day = ((h + m - 7 * n + 114) % 31) + 1;
	return date(day, month, year);
*/
	int golden_number = (year % 19) + 1;
	int dominical_number = (year + (year / 4) - (year / 100) + (year / 400)) % 7;
	int solar_correction = (year - 1600) / 100 - (year - 1600) / 400;
	int lunar_correction = (((year - 1400) / 100) * 8) / 25;
	int paschal_full_moon = (3 - 11 * golden_number + solar_correction - lunar_correction) % 30;

	while (!(dominical_number > 0)) {
		dominical_number += 7;
	}

	while (!(paschal_full_moon > 0)) {
		paschal_full_moon += 30;
	}

	if ((paschal_full_moon == 29) || (paschal_full_moon == 28 && golden_number > 11)) {
		paschal_full_moon -= 1;
	}

	int difference = (4 - paschal_full_moon - dominical_number) % 7;
	if (difference < 0) difference += 7;

	int day_easter = paschal_full_moon + difference + 1;
	if (day_easter < 11) {
		//# Easter occurs in March.
		//printf("(Easter: %2d/%2d/%4d)\t", day_easter + 21, 3, year);
		return date(day_easter + 21, 3, year);
	}
	else {
		//# Easter occurs in April.
		//printf("(Easter: %2d/%2d/%4d)\t", day_easter - 10, 4, year);
		return date(day_easter - 10, 4, year);
	}




    //return dt.date(year, month, day)
}
/*
class MovableFeast(metaclass=ABCMeta):
    """An abstract class for a movable feast.

    A movable feast must have two attributes:

    1. A name.
    2. A date.

    The name must correspond to the feast data in `movable_feasts_ferias_et_al.json`.

    """

    @property
    @abstractmethod
    def name(self):
        """Return the name of the feast."""
        raise NotImplementedError('A movable feast must have a name.')

    @abstractmethod
    def date(year):
        """Compute the date of the movable feast given the year."""
        raise NotImplementedError('A movable feast must have a date.')

    def __repr__(self):
        """Print the name of the feast."""
        return self.name
*/

//class GaudeteSunday(MovableFeast):
time64_t Tridentine::GaudeteSunday(int year) {
    /*"""Represents Gaudete Sunday."""

    name = 'Gaudete Sunday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Gaudete Sunday.

        Gaudete Sunday is the third Sunday of Advent.

        """
        xmas = dt.date(year - 1, 12, 25)
        return xmas - dt.timedelta(xmas.weekday() + 8)
        */
	time64_t xmas = nativity(year);
	return xmas - ((weekday(xmas) + 8) * SECS_PER_DAY);
}


//class AdventEmbertide(MovableFeast):
time64_t Tridentine::AdventEmbertide(int year, int day) {    
	/*"""Represents Advent Embertide."""

    name = 'Advent Embertide'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Advent Embertide.

        Advent Embertide is the Wednesday, Friday, and Saturday after Gaudete Sunday.

        """
        return sorted([GaudeteSunday.date(year) + dt.timedelta(i) for i in [3, 5, 6]])
		*/
	
	// day is 1..3, function will return -1 as time64_t value otherwise
	switch (day){
	case 1:
		return GaudeteSunday(year) + 3 * SECS_PER_DAY;
		break;
	case 2:
		return GaudeteSunday(year) + 5 * SECS_PER_DAY;
		break;
	case 3:
		return GaudeteSunday(year) + 6 * SECS_PER_DAY;
		break;

	default:
		return -1;
	}
}


//class SundayWithinTheOctaveOfXmas(MovableFeast):
time64_t Tridentine::SundayWithinTheOctaveOfXmas(int year) {
    /*"""Represents Sunday within the Octave of Christmas."""

    name = 'Sunday within the Octave of Christmas'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Sunday within the Octave of Easter."""
        xmas = dt.date(year - 1, 12, 25)
        sunday = xmas + dt.timedelta(6 - xmas.weekday())
        if sunday == xmas:
            sunday += dt.timedelta(7)
        return sunday*/

	time64_t xmas = nativity(year - 1);
	time64_t sunday = xmas + ((6 - weekday(xmas)) * SECS_PER_DAY);
	if (sunday == xmas) {
		//sunday += 7 * SECS_PER_DAY; // this would be handled by the Octave Day of Christmas
		return 0;
	}
	return sunday;
}


//class HolyName(MovableFeast):
time64_t Tridentine::HolyName(int year) {
	/*"""Represents the Feast of the Holy Name."""

    name = 'The Holy Name'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of the Holy Name.

        The Feast of the Holy Name is generally the first Sunday of the year, unless the
        first Sunday falls on January 1, January 6, or January 7, in which case the
        Feast of the Holy Name is moved to January 2.

        """
        new_years_day = dt.date(year, 1, 1)
        holy_name = new_years_day + dt.timedelta(6 - new_years_day.weekday())
        if holy_name in [new_years_day, dt.date(year, 1, 6), dt.date(year, 1, 7)]:
            return dt.date(year, 1, 2)
        return holy_name*/
	if (Tridentine::mass_type < MASS_1955) {
		return date(2, 1, year + 1); // can't happen (Holy Name not present in D.O. software for Mass < 1955)
	}

	time64_t new_years_day = date(1, 1, year);
	time64_t holy_name = new_years_day + ((6 - weekday(new_years_day)) * SECS_PER_DAY);
	if (holy_name == new_years_day || holy_name == date(6, 1, year) || holy_name == date(7, 1, year)) {
		return date(2, 1, year);
	}
	return holy_name;
}

uint8_t Tridentine::mass_type = MASS_1960; // set this to the mass in use. It affects whether HolyFamily is set a day before if it would fall on the 13th (which is the octave day of Epiphany)

//class HolyFamily(MovableFeast):
time64_t Tridentine::HolyFamily(int year) {
    /*"""Represents the Feast of the Holy Family."""

    name = 'The Holy Family'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of the Holy Family.

        The Feast of the Holy Family is the first Sunday after Three Kings Day.

        """
        epiphany = dt.date(year, 1, 6)
        delta = dt.timedelta(6 - epiphany.weekday())
        if delta == dt.timedelta(0):
            delta = dt.timedelta(7)
        return epiphany + delta*/
	
	time64_t epiphany = date(6, 1, year);
	//time64_t delta = (6 - weekday(epiphany)) * SECS_PER_DAY;
	//if (delta == 0) {
	//	delta = 7 * SECS_PER_DAY;
	//}
	//return epiphany + delta;

	time64_t holyfamily = sunday_after(epiphany);
	if (Tridentine::mass_type < MASS_1955 && sunday(date(6 + 7, 1, year))) {
		holyfamily -= SECS_PER_DAY;	//move HolyFamily back by one day if it falls on the Octave day of Epiphany (pre-1955 calendar) (see https://en.wikipedia.org/wiki/Holy_Family)
		// edit: Says also that Holy Family was introduced in 1921 (by Pope Benedict XV), so it can't be present in 1570, 1910 and Divino Afflatu (1911) Masses
		// so return a date that can't possibly match, to suppress the feast in these Masses
		//return sunday_after(date(6, 1, year + 1));
		
		// edit 2: D.O. has it present in Divino Afflatu Mass, and my copy generated it also for 1570 and 1910 Masses, in place of Sunday in the Octave of Epiphany.
		// So I'm going to include it for all.
	}
	return holyfamily;
}

time64_t Tridentine::Epiphany(int year) {
	return date(6, 1, year);
}

//class PloughMonday(MovableFeast):
time64_t Tridentine::PloughMonday(int year) {
    /*"""Represents Plough Monday."""

    name = 'Plough Monday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Plough Monday.

        Plough Monday is the first Monday after Three Kings Day.

        """
        epiphany = dt.date(year, 1, 6)
        if epiphany.weekday() == 6:
            return epiphany + dt.timedelta(1)
        return HolyFamily.date(year) + dt.timedelta(1)*/
	time64_t epiphany = date(6, 1, year);
	if (weekday(epiphany) == 6) {
		return epiphany + 1 * SECS_PER_DAY;
	}
	return HolyFamily(year) + 1 * SECS_PER_DAY;
}

//class AshWednesday(MovableFeast):
time64_t Tridentine::AshWednesday(int year) {
    /*"""Represents Ash Wednesday."""

    name = 'Ash Wednesday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Ash Wednesday.

        Ash Wednesday is forty days prior to Easter, excluding Sundays.

        """
        return Easter.date(year) - dt.timedelta(46)*/
	return Easter(year) - 46 * SECS_PER_DAY;
}

//class LentenEmbertide(MovableFeast):
time64_t Tridentine::LentenEmbertide(int year, int day) {
	/*"""Represents Lenten Embertide."""

    name = 'Lenten Embertide'

    @functools.lru_cache()
    def date(year):
        """Calculate the dates of Lenten Embertide.

        Lenten Embertide is the Wednesday, Friday, and Saturday after the first Sunday
        of Lent.

        """
        return [AshWednesday.date(year) + dt.timedelta(i) for i in [7, 9, 10]]*/

	// day is 1..3, function will return -1 as time64_t value otherwise
	switch (day) {
	case 1:
		return AshWednesday(year) + 7 * SECS_PER_DAY;
		break;
	case 2:
		return AshWednesday(year) + 9 * SECS_PER_DAY;
		break;
	case 3:
		return AshWednesday(year) + 10 * SECS_PER_DAY;
		break;

	default:
		return -1;
	}
}

//class Quinquagesima(MovableFeast):
time64_t Tridentine::Quinquagesima(int year) {
    /*"""Represents Quinquagesima."""

    name = 'Quinquagesima'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Quinquagesima.

        Quinquagesima is the Sunday before Ash Wednesday.

        """
        return AshWednesday.date(year) - dt.timedelta(3)*/
	return AshWednesday(year) - 3 * SECS_PER_DAY;
}

//class FatThursday(MovableFeast):
time64_t Tridentine::FatThursday(int year) {
	/*"""Represents Fat Thursday."""

		name = 'Fat Thursday'

		@functools.lru_cache()
		def date(year) :
		"""Calculate the date of Fat Thursday.

		Fat Thursday is the Thursday before Ash Wednesday.

		"""
		return AshWednesday.date(year) - dt.timedelta(6)*/
	return AshWednesday(year) - 6 * SECS_PER_DAY;
}

//class ShroveMonday(MovableFeast):
time64_t Tridentine::ShroveMonday(int year) {
	/*"""Represents Shrove Monday."""

		name = 'Shrove Monday'

		@functools.lru_cache()
		def date(year) :
		"""Calculate the date of Shrove Monday.

		Shrove Monday is the Monday before Ash Wednesday.

		"""
		return AshWednesday.date(year) - dt.timedelta(2)*/
	return AshWednesday(year) - 2 * SECS_PER_DAY;

}

//class MardiGras(MovableFeast):
time64_t Tridentine::MardiGras(int year) {
	/*"""Represents Mardi Gras."""

		name = 'Mardi Gras'

		@functools.lru_cache()
		def date(year) :
		"""Calculate the date of Mardi Gras.

		Mardi Gras is the Tuesday before Ash Wednesday.

		"""
		return AshWednesday.date(year) - dt.timedelta(1)*/
	return AshWednesday(year) - 1 * SECS_PER_DAY;

}

//class Sexagesima(MovableFeast):
time64_t Tridentine::Sexagesima(int year) {
    /*"""Represents Sexagesima."""

    name = 'Sexagesima'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Sexagesima.

        Sexagesima is the Sunday before Quinquagesima.

        """
        return Quinquagesima.date(year) - dt.timedelta(7)*/
	return Quinquagesima(year) - 7 * SECS_PER_DAY;
}


//class Septuagesima(MovableFeast):
time64_t Tridentine::Septuagesima(int year) {
    /*"""Represents Septuagesima."""

    name = 'Septuagesima'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Septuagesima.

        Septuagesima is the Sunday before Sexagesima.

        """
        return Sexagesima.date(year) - dt.timedelta(7)*/
	return Sexagesima(year) - 7 * SECS_PER_DAY;
}


//class StMatthias(MovableFeast):
time64_t Tridentine::StMatthias(int year) {
    /*"""Represents the Feast of St. Matthias."""

    name = 'St. Matthias'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of St. Matthias.

        The Feast of St. Matthias is generally February 24, but is moved to February 25
        on leap years.

        """
        if calendar.isleap(year):
            return dt.date(year, 2, 25)
        return dt.date(year, 2, 24)*/
	if (isleap(year)) {
		return date(25, 2, year);
	}
	return date(24, 2, year);
}

//class StGabrielOfOurLadyOfSorrows(MovableFeast):
time64_t Tridentine::StGabrielOfOurLadyOfSorrows(int year) {
	/*"""Represents the Feast of St. Gabriel of Our Lady of Sorrows."""

		name = 'St. Gabriel of Our Lady of Sorrows'

		@functools.lru_cache()
		def date(year) :
		"""Calculate the date of the Feast of St. Gabriel of Our Lady of Sorrows.

		The Feast of St.Gabriel of Our Lady of Sorrows is generally February 27, but is
		moved to February 28 on leap years.

		"""
		if calendar.isleap(year) :
			return dt.date(year, 2, 28)
			return dt.date(year, 2, 27)*/
	if (isleap(year)) {
		return date(28, 2, year);
	}
	return date(27, 2, year);
}

//class LaetareSunday(MovableFeast):
time64_t Tridentine::LaetareSunday(int year) {
    /*"""Represents Laetare Sunday."""

    name = 'Laetare Sunday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Laetare Sunday.

        Lateare Sunday is the fourth Sunday of Lent.

        """
        return Easter.date(year) - dt.timedelta(21)*/
	return Easter(year) - 21 * SECS_PER_DAY;
}

//class PassionSunday(MovableFeast):
time64_t Tridentine::PassionSunday(int year) {
	/*"""Represents Passion Sunday."""

		name = 'Passion Sunday'

		@functools.lru_cache()
		def date(year) :
		"""Calculate the date of Passion Sunday.

		Passion Sunday is the second Sunday before Easter.

		"""
		return Easter.date(year) - dt.timedelta(14)*/
	return Easter(year) - 14 * SECS_PER_DAY;
}

//class SevenSorrows(MovableFeast):
time64_t Tridentine::SevenSorrows(int year) {
    /*"""Represents the Feast of the Seven Sorrows."""

    name = 'The Seven Sorrows'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of the Seven Sorrows.

        The Feast of the Seven Sorrows of Mary is the Friday of Passion Week.

        """
        return PalmSunday.date(year) - dt.timedelta(2)*/
	return PalmSunday(year) - 2 * SECS_PER_DAY;
}

//class LadyDay(MovableFeast):
time64_t Tridentine::LadyDay(int year) {
    /*"""Represents Lady Day."""

    name = 'Lady Day'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Lady Day.

        Lady Day is generally March 25, except when March 25 falls in Holy Week or the
        first week of Eastertide, in which case it is transfered to the Monday after
        Quasimodo Sunday, or if it falls on another Sunday, in which case it is
        transferred to the following Monday.

        """
        lady_day = dt.date(year, 3, 25)
        if PalmSunday.date(year) <= lady_day <= QuasimodoSunday.date(year):
            return QuasimodoSunday.date(year) + dt.timedelta(1)
        elif lady_day.weekday() == 6:
            return lady_day + dt.timedelta(1)
        else:
            return lady_day*/
	time64_t lady_day = date(25, 3, year);
	if ((PalmSunday(year) <= lady_day) && (lady_day <= QuasimodoSunday(year))) {
		DEBUG_PRT.println(F("Lady Day transferred to day after Quasimodo Sunday, as it falls within Holy Week and Easter"));
		return QuasimodoSunday(year) + 1 * SECS_PER_DAY;
	}
	else if (weekday(lady_day) == 6) {
		DEBUG_PRT.println(F("Lady Day transferred to Monday after, as 25th March in on a Sunday"));
		return lady_day + 1 * SECS_PER_DAY;
	}
	else {
		return lady_day;
	}
}

bool Tridentine::IsLadyDay (time64_t datetime) 
{
	return issameday(datetime, LadyDay(year(datetime)));
}

time64_t Tridentine::StJoseph(int year) {
	time64_t st_joseph = date(19, 3, year);
	if (st_joseph >= PalmSunday(year) && st_joseph < Easter(year)) {
		// if it falls in holy week, the feast of St Joseph is transferred to the Tuesday after Low/Quasimodo Sunday
		return QuasimodoSunday(year) + (2 * SECS_PER_DAY);
	}
	else if (sunday(st_joseph)) {
		return st_joseph + SECS_PER_DAY; // transfer to monday 20th
	}

	return st_joseph;
}

//class PalmSunday(MovableFeast):
time64_t Tridentine::PalmSunday(int year) {
	/*"""Represents Palm Sunday."""

	name = 'Palm Sunday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Palm Sunday.

		Palm Sunday is the Sunday before Easter.

		"""
		return Easter.date(year) - dt.timedelta(7)*/
	return Easter(year) - 7 * SECS_PER_DAY;
}

//class MondayOfHolyWeek(MovableFeast):
time64_t Tridentine::MondayOfHolyWeek(int year) {
    /*"""Represents the Monday of Holy Week."""

    name = 'Monday of Holy Week'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Monday in Holy Week."""
        return PalmSunday.date(year) + dt.timedelta(1)*/
	return PalmSunday(year) + 1 * SECS_PER_DAY;
}

//class TuesdayOfHolyWeek(MovableFeast):
time64_t Tridentine::TuesdayOfHolyWeek(int year) {
	/*"""Represents the Tuesday of Holy Week."""

	name = 'Tuesday of Holy Week'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Tuesday in Holy Week."""
		return PalmSunday.date(year) + dt.timedelta(2)*/
	return PalmSunday(year) + 2 * SECS_PER_DAY;
}

//class SpyWednesday(MovableFeast):
time64_t Tridentine::SpyWednesday(int year) {
	/*"""Represents Spy Wednesday."""

	name = 'Spy Wednesday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Spy Wednesday.

		Spy Wednesday is the Wednesday before Easter.

		"""
		return Easter.date(year) - dt.timedelta(4)*/
	return Easter(year) - 4 * SECS_PER_DAY;
}

//class MaundyThursday(MovableFeast):
time64_t Tridentine::MaundyThursday(int year) {
    /*"""Represents Maundy Thursday."""

    name = 'Maundy Thursday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Maundy Thursday.

        Maundy Thursday is the Thursday before Easter.

        """
        return Easter.date(year) - dt.timedelta(3)*/
	return Easter(year) - 3 * SECS_PER_DAY;
}

//class GoodFriday(MovableFeast):
time64_t Tridentine::GoodFriday(int year) {
	/*"""Represents Good Friday."""

	name = 'Good Friday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Good Friday.

		Good Friday is the Friday before Easter.

		"""
		return Easter.date(year) - dt.timedelta(2)*/
	return Easter(year) - 2 * SECS_PER_DAY;
}

bool Tridentine::IsGoodFriday(time64_t datetime) {
	int year = ::year(datetime);
	return issameday(GoodFriday(year), datetime);
}


//class HolySaturday(MovableFeast):
time64_t Tridentine::HolySaturday(int year) {
	/*"""Represents Holy Saturday."""

	name = 'Holy Saturday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Holy Saturday.

		Holy Saturday is the Saturday before Easter.

		"""
		return Easter.date(year) - dt.timedelta(1)*/
	return Easter(year) - 1 * SECS_PER_DAY;
}

bool Tridentine::IsHolySaturday(time64_t datetime) {
	int year = ::year(datetime);
	return issameday(HolySaturday(year), datetime);
}

//class Easter(MovableFeast):
time64_t Tridentine::Easter(int year) {
	/*"""Represents Easter."""

	name = 'Easter'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter.

		This is an alias for `computus`.

		"""
		return computus(year)*/
	return computus(year);
}

//class EasterMonday(MovableFeast):
time64_t Tridentine::EasterMonday(int year) {
	/*"""Represents Easter Monday."""

	name = 'Easter Monday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter Monday."""
		return Easter.date(year) + dt.timedelta(1)*/
	return Easter(year) + 1 * SECS_PER_DAY;
}

//class EasterTuesday(MovableFeast):
time64_t Tridentine::EasterTuesday(int year) {
	/*"""Represents Easter Tuesday."""

	name = 'Easter Tuesday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter Tuesday."""
		return Easter.date(year) + dt.timedelta(2)*/
	return Easter(year) + 2 * SECS_PER_DAY;
}

//class EasterWednesday(MovableFeast):
time64_t Tridentine::EasterWednesday(int year) {
	/*"""Represents Easter Wednesday."""

	name = 'Easter Wednesday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter Wednesday."""
		return Easter.date(year) + dt.timedelta(3)*/
	return Easter(year) + 3 * SECS_PER_DAY;
}

//class EasterThursday(MovableFeast):
time64_t Tridentine::EasterThursday(int year) {
	/*"""Represents Easter Thursday."""

	name = 'Easter Thursday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter Thursday."""
		return Easter.date(year) + dt.timedelta(4)*/
	return Easter(year) + 4 * SECS_PER_DAY;
}

//class EasterFriday(MovableFeast):
time64_t Tridentine::EasterFriday(int year) {
	/*"""Represents Easter Friday."""

	name = 'Easter Friday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter Friday."""
		return Easter.date(year) + dt.timedelta(5)*/
	return Easter(year) + 5 * SECS_PER_DAY;
}

//class EasterSaturday(MovableFeast):
time64_t Tridentine::EasterSaturday(int year) {
	/*"""Represents Easter Saturday."""

	name = 'Easter Saturday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Easter Saturday."""
		return Easter.date(year) + dt.timedelta(6)*/
	return Easter(year) + 6 * SECS_PER_DAY;
}

//class QuasimodoSunday(MovableFeast):
time64_t Tridentine::QuasimodoSunday(int year) {
	/*"""Represents Quasimodo Sunday."""

	name = 'Quasimodo Sunday'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of Quasimodo Sunday.

		Quasimodo Sunday is the first Sunday after Easter.

		"""
		return Easter.date(year) + dt.timedelta(7)*/
	return Easter(year) + 7 * SECS_PER_DAY;
}

//class MisericordiaSunday(MovableFeast):
time64_t Tridentine::MisericordiaSunday(int year) {
    /*"""Represents Misericordia Sunday."""

    name = 'Misericordia Sunday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Misericordia Sunday.

        Misericordia Sunday is the second Sunday after Easter.

        """
        return Easter.date(year) + dt.timedelta(14)*/
	return Easter(year) + 14 * SECS_PER_DAY;
}


//class JubilateSunday(MovableFeast):
time64_t Tridentine::JubilateSunday(int year) {
    /*"""Represents Jubilate Sunday."""

    name = 'Jubilate Sunday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Jubilate Sunday.

        Jubilate Sunday is the third Sunday after Easter.

        """
        return Easter.date(year) + dt.timedelta(21)*/
	return Easter(year) + 21 * SECS_PER_DAY;
}


//class CantateSunday(MovableFeast):
time64_t Tridentine::CantateSunday(int year) {
    /*"""Represents Cantate Sunday."""

    name = 'Cantate Sunday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Cantate Sunday.

        Cantate Sunday is the fourth Sunday after Easter.

        """
        return Easter.date(year) + dt.timedelta(28)*/
	return Easter(year) + 28 * SECS_PER_DAY;
}


//class MajorRogation(MovableFeast):
time64_t Tridentine::MajorRogation(int year) {
    /*"""Represents the Major Rogation."""

    name = 'Major Rogation'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Major Rogation.

        The Major Rogation is generally April 25, unless it falls on Easter, in which
        case it is transferred to the following Tuesday.

        """
        major_rogation = dt.date(year, 4, 25)
        if major_rogation != Easter.date(year):
            return major_rogation
        else:
            return major_rogation + dt.timedelta(2)*/
	time64_t major_rogation = date(25, 4, year);
	if (major_rogation != Easter(year)) {
		return major_rogation;
	}
	else {
		return major_rogation + 2 * SECS_PER_DAY; // no need to calculate easter twice - if in here, major rogation == easter sunday
	}
}

time64_t Tridentine::AscensionVigil(int year) {
	/*
	Vigil of the Ascension

	Occurs one day before Ascension Thursday
	*/

	return Ascension(year) - SECS_PER_DAY;
}

//class Ascension(MovableFeast):
time64_t Tridentine::Ascension(int year) {
    /*"""Represents Ascension Thursday."""

    name = 'Ascension'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Ascension Thursday.

        Ascension Thursday is the fourtieth day of Eastertide.

        """
        return Easter.date(year) + dt.timedelta(39)*/
	return Easter(year) + 39 * SECS_PER_DAY;
}

time64_t Tridentine::SundayAfterAscension(int year) {
	/*
		Sunday after the Ascension
	*/
	return Ascension(year) + 3 * SECS_PER_DAY;
}

//class MinorRogation(MovableFeast):
time64_t Tridentine::MinorRogation(int year, int day) {
    /*"""Represents the Minor Rogation."""

    name = 'Minor Rogation'

    @functools.lru_cache()
    def date(year):
        """Calculate the dates of the Minor Rogation.

        The Minor Rogation is the Monday, Tuesday, and Wednesday before Ascension
        Thursday.

        """
        return [Ascension.date(year) - dt.timedelta(i) for i in range(3, 0, -1)]*/

	// 3, 0 -1? should be 1 2 3 ?
	switch (day) {
	case 1:
		return Ascension(year) - 3 * SECS_PER_DAY;
		break;
	case 2:
		return Ascension(year) - 2 * SECS_PER_DAY;
		break;
	case 3:
		return Ascension(year) - 1 * SECS_PER_DAY;
		break;

	default:
		return -1;
	}
}


//class Pentecost(MovableFeast):
time64_t Tridentine::PentecostVigil(int year) {
	/*"""Represents Pentecost Vigil."""

	name = 'Vigil Mass of Pentecost'

	@functools.lru_cache()
	def date(year):
		"""Calculate the date of The Vigil of Pentecost.

		The Vigil of Pentecost is the day before Pentecost.
		49 days after Easter

		"""
		return Easter.date(year) + dt.timedelta(49)*/
	return Easter(year) + 48 * SECS_PER_DAY;
}

//class Pentecost(MovableFeast):
time64_t Tridentine::Pentecost(int year) {
    /*"""Represents Pentecost."""

    name = 'Pentecost'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Pentecost.

        Pentecost is the fiftieth and final day of Eastertide.

        """
        return Easter.date(year) + dt.timedelta(49)*/
	return Easter(year) + 49 * SECS_PER_DAY;
}


//class PentecostMonday(MovableFeast):
time64_t Tridentine::PentecostMonday(int year) {
    /*"""Represents Pentecost Monday."""

    name = 'Pentecost Monday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Pentecost Monday."""
        return Pentecost.date(year) + dt.timedelta(1)*/
	return Pentecost(year) + 1 * SECS_PER_DAY;
}


//class PentecostTuesday(MovableFeast):
time64_t Tridentine::PentecostTuesday(int year) {
    /*"""Represents Pentecost Tuesday."""

    name = 'Pentecost Tuesday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Pentecost Tuesday."""
        return Pentecost.date(year) + dt.timedelta(2)*/
	return Pentecost(year) + 2 * SECS_PER_DAY;
}


//class WhitEmbertide(MovableFeast):
time64_t Tridentine::WhitEmbertide(int year, int day) {
    /*"""Represents Whit Embertide."""

    name = 'Whit Embertide'

    @functools.lru_cache()
    def date(year):
        """Calculate the dates of Whit Embertide.

        Whit Embertide is the Wednesday, Friday, and Saturday after Pentecost.

        """
        return sorted([Pentecost.date(year) + dt.timedelta(i) for i in [3, 5, 6]])*/
	switch (day) {
	case 1:
		return Pentecost(year) + 3 * SECS_PER_DAY;
		break;
	case 2:
		return Pentecost(year) + 5 * SECS_PER_DAY;
		break;
	case 3:
		return Pentecost(year) + 6 * SECS_PER_DAY;
		break;

	default:
		return -1;
	}
}


//class ThursdayInPentecostWeek(MovableFeast):
time64_t Tridentine::ThursdayInPentecostWeek(int year) {
    /*"""Represents Thursday in Pentecost Week."""

    name = 'Thursday in Pentecost Week'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Thursday in Pentecost Week."""
        return Pentecost.date(year) + dt.timedelta(4)*/
	return Pentecost(year) + 4 * SECS_PER_DAY;
}


//class TrinitySunday(MovableFeast):
time64_t Tridentine::TrinitySunday(int year) {
    /*"""Represents Trinity Sunday."""

    name = 'Trinity Sunday'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Trinity Sunday.

        Trinity Sunday is the Sunday after Pentecost.

        """
        return Pentecost.date(year) + dt.timedelta(7)*/
	return Pentecost(year) + 7 * SECS_PER_DAY;
}


//class CorpusChristi(MovableFeast):
time64_t Tridentine::CorpusChristi(int year) {
    /*"""Represents the Feast of Corpus Christi."""

    name = 'Corpus Christi'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of Corpus Christi.

        The Feast of Corpus Christi is the Thursday after Trinity Sunday.

        """
        return TrinitySunday.date(year) + dt.timedelta(4)*/
	return TrinitySunday(year) + 4 * SECS_PER_DAY;
}


//class SacredHeart(MovableFeast):
time64_t Tridentine::SacredHeart(int year) {
    /*"""Represents the Feast of the Sacred Heart."""

    name = 'The Sacred Heart'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of the Sacred Heart.

        The Feast of the Sacred Heart is the Friday in the week after the Feast of
        Corpus Christi.

        """
        return CorpusChristi.date(year) + dt.timedelta(8)*/
	return CorpusChristi(year) + 8 * SECS_PER_DAY;
}


//class PetersPence(MovableFeast):
time64_t Tridentine::PetersPence(int year) {
    /*"""Represents Peter's Pence."""

    name = 'Peter\'s Pence'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of Peter's Pence.

        Peter's Pence is the Sunday nearest to the Feast of SS. Peter & Paul.

        """
        ss_peter_paul = dt.date(year, 6, 29)
        return ss_peter_paul + dt.timedelta(((2 - ss_peter_paul.weekday()) % 7) - 3)*/
	time64_t ss_peter_paul = date(29, 6, year);
	return ss_peter_paul + ((((2 - weekday(ss_peter_paul)) % 7) - 3) * SECS_PER_DAY);
}


//class MichaelmasEmbertide(MovableFeast):
time64_t Tridentine::MichaelmasEmbertide(int year, int day) {
    /*"""Represents Michaelmas Embertide."""

    name = 'Michaelmas Embertide'

    @functools.lru_cache()
    def date(year):
        """Calculate the dates of Michaelmas Embertide.

        Michaelmas Embertide is the Wednesday, Friday, and Saturday after the third
        Sunday of September.

        """
        first_sunday_in_september = (
            dt.date(year, 9, 1) + dt.timedelta(6 - dt.date(year, 9, 1).weekday())
        )
        third_sunday_in_september = first_sunday_in_september + dt.timedelta(14)
        return [third_sunday_in_september + dt.timedelta(i) for i in [3, 5, 6]]*/
	time64_t first_sunday_in_september = date(1, 9, year) + ((6 - weekday(date(1, 9, year))) * SECS_PER_DAY);
	time64_t third_sunday_in_september = first_sunday_in_september + 14 * SECS_PER_DAY;

	switch (day) {
	case 1:
		return third_sunday_in_september + 3 * SECS_PER_DAY;
		break;
	case 2:
		return third_sunday_in_september + 5 * SECS_PER_DAY;
		break;
	case 3:
		return third_sunday_in_september + 6 * SECS_PER_DAY;
		break;

	default:
		return -1;
	}
}

time64_t Tridentine::AllSouls(int year) {
	/*
	Calculate the date of All Souls day

	All Souls day is 2nd November, unless it falls on a Sunday,
	in which case it is transferred to Monday 3rd
	*/

	time64_t all_souls = date(2, 11, year);
	/*
	if (weekday(all_souls) == 6) {
		all_souls += 1 * SECS_PER_DAY;	// can't find a Rubric for the transference of All Souls to the 3rd
	}
	*/
	return all_souls;
}

//class ChristTheKing(MovableFeast):
time64_t Tridentine::ChristTheKing(int year) {
    /*"""Represents the Feast of Christ the King."""

    name = 'Christ the King'

    @functools.lru_cache()
    def date(year):
        """Calculate the date of the Feast of Christ the King.

        The Feast of Christ the King is the last Sunday of October.

        """
        halloween = dt.date(year, 10, 31)
        return halloween - dt.timedelta((halloween.weekday() + 1) % 7)*/
	time64_t halloween = date(31, 10, year);
	return halloween - (((weekday(halloween) + 1) % 7) * SECS_PER_DAY);
}

#ifdef _WIN32
bool Tridentine::print_season = false;
#endif

uint8_t Tridentine::Season(time64_t datetime) {
	int year = ::year(datetime);
	time64_t nativity = date(25, 12, year);
	
	// Advent (Violet)
	if (datetime >= first_advent_sunday(year) && datetime < nativity) {
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='color:white; background-color:purple;'> Advent </span>");
		}
#endif
		return SEASON_ADVENT;

	}

	// Christmas (White)
	time64_t epiphany = date(6, 1, year);
	if (!(datetime < nativity && datetime > epiphany)) {		
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style=';'>  </span>");
		}
#endif
		return SEASON_CHRISTMAS;
	}

	if (datetime >= epiphany && datetime < Septuagesima(year)) {
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='border 1px solid grey;'> Christmas </span>");
		}
#endif
		return SEASON_EPIPHANY;
	}

	// Septuagesima - Ash Wednesday
	// Violet vestments worn only on Sundays, not weekdays before Lent begins
	// See https://catholicherald.co.uk/commentandblogs/2018/01/28/what-is-septuagesima/
	if (datetime >= Septuagesima(year) && datetime < AshWednesday(year)) {
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='background-color:lightpurple;'> Septuagesima </span>");
		}
#endif
		return SEASON_SEPTUAGESIMA;
	}

	// Lent (Violet)
	if (datetime >= AshWednesday(year) && datetime < Easter(year)) {
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='color:white; background-color:purple;'> Lent </span>");
		}
#endif
		return SEASON_LENT;
	}

	// Easter (White)
	if (datetime >= Easter(year) && datetime < Pentecost(year)) {
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='border 1px solid grey;'> Easter </span>");
		}
#endif
		return SEASON_EASTER;
	}

	// Octave of Pentecost (Red)
	if (datetime >= Pentecost(year) && datetime < TrinitySunday(year)) { // Octave of Pentecost
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='background-color:darkred;'> Pentecost </span>");
		}
#endif
		return SEASON_PENTECOST;
	}

	// from the first week after Pentecost up to the beginning of Advent in the next Liturgical year
	if ((datetime >= TrinitySunday(year)) && datetime < first_advent_sunday(year)) {
#ifdef _WIN32
		if (Tridentine::print_season) {
			Bidi::printf("<span style='background-color:darkgreen;'> After Pentecost </span>");
		}
#endif
		return SEASON_AFTER_PENTECOST;
	}

#ifdef _WIN32
	if (Tridentine::print_season) {
		Bidi::printf("<span style='background-color:lightgrey;'> Ordinary </span>");
	}
#endif
	return SEASON_ORDINARY;
}

time64_t Tridentine::Season_beginning(uint8_t season, time64_t datetime) {
	int year = ::year(datetime);

	if (season == SEASON_ADVENT) return first_advent_sunday(year);
	if (season == SEASON_CHRISTMAS) {
		if (year == liturgical_year(datetime)) { // is between January and first Advent Sunday
			return nativity(year - 1); // so Christmas was Dec 25th last year
		}
		else {
			return nativity(year); // otherwise after first Advent Sunday and before New Year, so Christmas is this year
		}
	}
	if (season == SEASON_EPIPHANY) return date(6, 1, year);
	if (season == SEASON_SEPTUAGESIMA) return Septuagesima(year);
	if (season == SEASON_LENT) return AshWednesday(year);
	if (season == SEASON_EASTER) return Easter(year);
	if (season == SEASON_PENTECOST) return Pentecost(year);
	if (season == SEASON_AFTER_PENTECOST) return TrinitySunday(year);

	DEBUG_PRT.println(F("Season_beginning(): season unset"));
	return datetime;
}


uint8_t Tridentine::Season_Week(time64_t datetime, uint8_t season) {
	time64_t week1_beginning = Season_beginning(season, datetime);
	
	int year = ::year(datetime);
	uint8_t week = 0;

	if (!sunday(week1_beginning)) { 
		// Lent begins on Ash Wednesday. 
		// Epiphany is on the 6th Jan, which can be a day other than Sunday
		// For advent, first sunday is in week one, not second sunday
		week1_beginning = sunday_after(week1_beginning);
		week += 1; // will be the first Sunday after
	}

	if (week1_beginning <= datetime) {
		week += (uint8_t)((date_difference(week1_beginning, datetime) / (SECS_PER_DAY * DAYS_PER_WEEK)));
	}

	if (season == SEASON_AFTER_PENTECOST || season == SEASON_ADVENT) {
		week += 1; // After Pentecost season starts with first sunday after Pentecost (Trinity Sunday), so Pentecost itself is one more week earlier
	}			   // The first Sunday in Advent is numbered 1, not 0

#ifdef _WIN32
	if (Tridentine::print_season) {
		Bidi::printf("<span style='background-color:yellow; font-weight: bold;'> %d </span>", week);
	}
#endif

	return week;
}

void Tridentine::ColourAndClass(time64_t datetime, uint8_t& col, uint8_t& cls) {
	ColourAndClass(datetime, true, col, cls);
}

void Tridentine::ColourAndClass(time64_t datetime, bool doRogations, uint8_t& col, uint8_t& cls) {
	col = TR_LIT_COLOUR_GREEN;
	cls = 4;
	uint8_t season = Season(datetime);
	int year = ::year(datetime);

	// handle single days
	if (issameday(datetime, GaudeteSunday(year))) {
		col = TR_LIT_COLOUR_ROSE;
		cls = 1;
		return;
	}

	if (issameday(datetime, HolyFamily(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 2;
		return;
	}

	if (issameday(datetime, StGabrielOfOurLadyOfSorrows(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 3;
		return;
	}

	if (issameday(datetime, LadyDay(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 1;
		return;
	}

	if (issameday(datetime, StJoseph(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 1;
		return;
	}

	if (issameday(datetime, LaetareSunday(year))) {
		col = TR_LIT_COLOUR_ROSE;
		cls = 1;
		return;
	}

	if (issameday(datetime, GoodFriday(year))) {
		cls = 1;
		col = TR_LIT_COLOUR_BLACK;
		return;
	}


	if (issameday(datetime, StMatthias(year))) {
		cls = 2;	// feast of St Matthias
		col = TR_LIT_COLOUR_RED;
	
		if (issameday(datetime, Sexagesima(year))) {
			cls = 2;	// feast of St Matthias is not celebrated if it falls on same day as Sexagesima 
			col = TR_LIT_COLOUR_VIOLET;
		}
		
		return;
	}

	if (doRogations) {
		if (issameday(datetime, MinorRogation(year, 1)) ||
			issameday(datetime, MinorRogation(year, 2)) ||
			issameday(datetime, MinorRogation(year, 3))) {
			cls = 2;
			col = TR_LIT_COLOUR_VIOLET;
			return;
		}
	}

	// both Sundays and weekdays in the Octave of Pentecost use Red colours
	if (season == SEASON_PENTECOST || issameday(datetime, PentecostVigil(year))) { // Octave of Pentecost
		col = TR_LIT_COLOUR_RED;
		cls = 1;
		return;
	}

	if (season == SEASON_EPIPHANY && Season_Week(datetime, season) < 2) {
		col = TR_LIT_COLOUR_WHITE; // white continues to be worn up until the first Sunday after Epiphany
		return;
	}

	if (issameday(datetime, TrinitySunday(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 1;
		return;
	}

	if (issameday(datetime, CorpusChristi(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 1;
		return;
	}

	if (issameday(datetime, ChristTheKing(year))) {
		col = TR_LIT_COLOUR_WHITE;
		cls = 1;
		return;
	}

	if (issameday(datetime, AllSouls(year))) {
		col = TR_LIT_COLOUR_BLACK;
		cls = 1;
		return;
	}

	if (sunday(datetime)) { // is a Sunday
		cls = 2;
		switch (season) {
		case SEASON_ADVENT:
			col = TR_LIT_COLOUR_VIOLET;
			cls = 1;

			if (datetime == GaudeteSunday(year)) {
				col = TR_LIT_COLOUR_ROSE;
			}
			break;

		case SEASON_CHRISTMAS:
			col = TR_LIT_COLOUR_WHITE;
			// Sundays in Christmas cls = 2
			break;

		case SEASON_SEPTUAGESIMA:
			col = TR_LIT_COLOUR_VIOLET; // nb. Violet only worn on Sundays in this pre-lent period
			// Sundays in this period are cls 2
			break;

		case SEASON_LENT:
			cls = 1;
			col = TR_LIT_COLOUR_VIOLET;

			if (datetime == LaetareSunday(year)) {
				col = TR_LIT_COLOUR_ROSE;
			}
			break;

		case SEASON_EASTER:
			col = TR_LIT_COLOUR_WHITE;
			if (issameday(datetime, Easter(year) || issameday(datetime, QuasimodoSunday(year)))) {
				cls = 1; // Easter Sunday and Low Sunday are both Class 1
			}
			break;

		default:
			col = TR_LIT_COLOUR_GREEN;
			break;
		}
		return;
	}
	else {	// is a weekday (Feria default class = 4)
		switch (season) {
		case SEASON_ADVENT:
			col = TR_LIT_COLOUR_VIOLET;
			cls = 3; // Feria of Advent
			if (datetime >= GaudeteSunday(year)) {
				cls = 2; // Greater Feria of Advent
			}

			// ember days of advent are also Violet
			break;

		case SEASON_CHRISTMAS:
			col = TR_LIT_COLOUR_WHITE;
			if (year < liturgical_year(datetime)) {	// if in Christmas season and liturgical year is
				cls = 2; // In Christmas Octave		// one more than current year, then still before Octave Day of Christmas - after which, Feria are class 4
			}
			break;

		case SEASON_SEPTUAGESIMA:
			col = TR_LIT_COLOUR_GREEN; // nb. Violet only worn on Sundays in this pre-lent period
			break;

		case SEASON_LENT:
			cls = 3;
			col = TR_LIT_COLOUR_VIOLET;

			if (datetime >= PalmSunday(year) && datetime < GoodFriday(year)) { // Holy Week
				cls = 1;
			}

			// ember days of lent are also Violet
			break;

		case SEASON_EASTER:
			col = TR_LIT_COLOUR_WHITE;
			if (datetime >= Easter(year) && datetime < QuasimodoSunday(year)) {
				cls = 1; // Weekdays of Easter week are class 1, class 4 after that
			}
			break;

		case SEASON_PENTECOST:
			col = TR_LIT_COLOUR_GREEN;
			
			if (IsEmberDay(datetime)) {
				col = TR_LIT_COLOUR_RED; // embertide in Pentecost
			}
			break;

		default:
			col = TR_LIT_COLOUR_GREEN;

			if (IsEmberDay(datetime)) {
				col = TR_LIT_COLOUR_VIOLET; // must be Michaelmas embertide
			}
			break;
		}
		return;
	}
}

bool Tridentine::IsEmberDay(time64_t datetime) {
	int year = ::year(datetime);
	uint8_t season = Season(datetime);
	
	bool bIsEmbertide = false;

	for (uint8_t i = 1; i <= 3; i++) {
		switch (season) {
		case SEASON_ADVENT:
			bIsEmbertide = (issameday(datetime, AdventEmbertide(year, i)));
			break;

		case SEASON_LENT:
			bIsEmbertide = (issameday(datetime, LentenEmbertide(year, i)));
			break;

		case SEASON_PENTECOST:
			bIsEmbertide = (issameday(datetime, WhitEmbertide(year, i)));
			break;

		default: // Michaelmas Embertide
			bIsEmbertide = (issameday(datetime, MichaelmasEmbertide(year, i)));
			break;
		}
		if (bIsEmbertide) break;
	}

	return bIsEmbertide;
}

void Tridentine::GetDay(time64_t datetime, String& Mass) {
	bool bSunday = sunday(datetime);
	int year = ::year(datetime);

	Mass = "";

	uint8_t season = Season(datetime);
	uint8_t season_week = Season_Week(datetime, season);
	uint8_t octave_daynumber = 0;

	String yml_season = "";
	String yml_path = "";
	String yml_subpath = "";

	if (bSunday) {
		yml_path = F("sunday");
	}
	else {
		yml_path = F("ferial");
	}

	bool bNoOutput = false; // if nothing is to be returned, eg. on sundays which will always be feast days, no point in searching for a yml key as it will be overridden by the feast (saves power)

	switch (season) {
	case SEASON_ADVENT:
		yml_season = F("advent.");
		if (IsEmberDay(datetime)) {
			yml_path = F("ember_day");
		}
		else if (datetime >= GaudeteSunday(year) && !bSunday) {
			yml_path = F("greater_ferial");
		}
		break;

	case SEASON_CHRISTMAS:
		yml_season = F("christmas.");
		if (datetime > nativity(year) && datetime < date(1, 1, year + 1)) {
			// is in Nativity Octave
			yml_subpath = F("nativity_octave.");
			if (!bSunday) {
				octave_daynumber = (uint8_t)(((datetime - nativity(year)) / SECS_PER_DAY) + 1);
			}
		}
		break;

	case SEASON_EPIPHANY:
		yml_season = F("epiphany.");
		break;

	case SEASON_SEPTUAGESIMA:
		yml_season = F("septuagesima.");
		if (bSunday) {
			bNoOutput = true;
		}
		break;

	case SEASON_LENT:
		yml_season = F("lent.");
		if (datetime >= (AshWednesday(year) + SECS_PER_DAY) && datetime < sunday_after(AshWednesday(year))) {
			// After Ashes
			if (!bSunday) {
				yml_subpath = F("after_ashes.");
			}
			else {
				bNoOutput = true;
			}
		}

		if (datetime >= PassionSunday(year) && datetime < PalmSunday(year)) {
			// In Passion Week
			if (!bSunday) {
				yml_subpath = F("passion_week.");
			}
			else {
				bNoOutput = true;
			}
		}

		if (datetime >= PalmSunday(year) && datetime < Easter(year)) {
			// In Holy Week
			if (!bSunday) {
				if (weekday(datetime) == PY_THU) {
					// Maundy Thursday
					bNoOutput = true; // Will be taken care of as a moveable feast
				}
				else {
					yml_subpath = F("holy_week.");
				}
			}
			else {
				bNoOutput = true;
			}
		}

		if (!bSunday && IsEmberDay(datetime)) {
			yml_path = F("ember_day");
		}
		break;

	case SEASON_EASTER:
		yml_season = F("easter.");
		if (datetime > Easter(year) && datetime < QuasimodoSunday(year)) {
			// is in Easter Octave
			if (!bSunday) {
				yml_subpath = F("octave.");
			}
			else {
				bNoOutput = true;
			}
		}
		else if (datetime > (Ascension(year) + SECS_PER_DAY) && datetime < Pentecost(year)) {
			yml_season = F("ascension.");
			if (bSunday) {
				bNoOutput = true;
			}
		}
		break;

	case SEASON_PENTECOST:
		yml_season = F("pentecost.");
		
		if (!bSunday) {
			if (IsEmberDay(datetime)) {
				yml_path = F("ember_day");
			}
		}
		else {
			bNoOutput = true;
		}
		break;

	case SEASON_AFTER_PENTECOST:
		// from the first week after Pentecost up to the beginning of Advent in the next Liturgical year
		yml_season = F("after_pentecost.");

		if (bSunday) {
			uint8_t after_pentecost_numweeks = Season_Week(first_advent_sunday(year) - SECS_PER_WEEK, season);

			if (issameday(sunday_after(datetime), first_advent_sunday(year))) {
				yml_season += F("last.");
			}
			else {
				if (season_week > 23) {
					yml_season = F("epiphany.resumed.");
					season_week = season_week + 7 - after_pentecost_numweeks;
				}
			}
		}
		break;

	default:
		bNoOutput = true;
	}

	if (!bNoOutput) {
		Yml i18n;
		Ordinalizer ordinalizer;

		yml_path = String(F("tridentine.season.")) + yml_season + yml_subpath + yml_path;
		Mass = i18n.get(yml_path);

		uint8_t wday = weekday(datetime, false); // get weekday 0=sun 6=sat
		uint8_t m = ::month(datetime);

		String Weekday = i18n.get(String(F("weekday.")) + String(wday));
		String Month = i18n.get(String(F("month.")) + String(m));

		Mass.replace(String(F("%{weekday}")), Weekday);
		Mass.replace(String(F("%{week}")), ordinalizer.ordinalize(season_week));

		if (octave_daynumber > 0) {
			Mass.replace(String(F("%{day}")), ordinalizer.ordinalize(octave_daynumber));
		}
	}
}

void Tridentine::GetFileDir(time64_t datetime, String& FileDir_Season, String& FileDir_Saint) {
	DEBUG_PRT.print(F("Tridentine::GetFileDir():"));

	bool bSunday = sunday(datetime);
	int year = ::year(datetime);

	int day_of_month = dayofmonth(datetime);
	int month_of_year = monthofyear(datetime);
	int day = weekday(datetime, true);

	FileDir_Season = "";
	FileDir_Saint = "";

	uint8_t season = Season(datetime);
	uint8_t season_week = Season_Week(datetime, season);
	uint8_t octave_daynumber = 0;

	bool bOverrideIfFeast = false; // if set, then the string in the variable fd will be used as the directory name only if there is no feast day on the same day (these are the month/day folders, eg 1962/01/05/)
	
	String dir_season = "";
	String dir_sub = "";
	String dir_subsub = "";
	String dir_day = "";

	DEBUG_PRT.print(F("0 "));

	switch (season) {
	case SEASON_ADVENT:
		//fd = "Advent/";
		dir_season = F("Advent");

		if (bSunday) {
			dir_sub = F("Sunday");
			dir_day = String(season_week);
			break;
		}

		if (IsEmberDay(datetime)) {
			dir_sub = F("Ember");
			dir_day = (FPSTR(WeekDays[day]));
		}
		break;

	case SEASON_CHRISTMAS:
		dir_season = F("Christmas");

		if (issameday(datetime, nativity(year))) { // Christmas Day
			dir_day = F("Day");
			break;
		}

		if (issameday(datetime, HolyName(year))) {
			dir_day = F("HolyName");
			break;
		}

		if (bSunday && !issameday(datetime, nativity(year)) && datetime > nativity(year) && datetime < date(1, 1, year + 1)) {
			// Sunday in the Octave of Christmas
			dir_day = F("Sunday");
			break;
		}

		if (!bSunday && datetime > date(1, 1, year) && datetime < HolyName(year)) {
			dir_day = F("Feria");
			bOverrideIfFeast = true;
		}
		break;

	case SEASON_EPIPHANY:
		if (issameday(datetime, HolyFamily(year))) {
			dir_season = F("Christmas");
			dir_day = F("HolyFamily");
			break;
		}

		if (bSunday) {
			dir_season = F("Epiphany");
			dir_sub = String(season_week);
			dir_day = F("Sunday");
			break;
		}
		else {
			dir_season = F("Epiphany");
			dir_sub = F("1");
			dir_day = F("Sunday");
			bOverrideIfFeast = true;
		}

		// Holy Family is the first Sunday after Epiphany. The 1st Sunday Mass is celebrated on Feria during the season of Epiphany (if there is no Feast day on that day)
		break;

	case SEASON_SEPTUAGESIMA:
		if (issameday(datetime, Septuagesima(year))) {
			dir_day = F("Septuagesima");
			break;
		}

		if (issameday(datetime, Sexagesima(year))) {
			dir_day = F("Sexagesima");
			break;
		}

		if (issameday(datetime, Quinquagesima(year))) {
			dir_day = F("Quinquagesima");
			break;
		}
		break;

	case SEASON_LENT:
		dir_season = F("Lent");

		if (datetime >= (AshWednesday(year) + SECS_PER_DAY) && datetime < sunday_after(AshWednesday(year))) {
			dir_sub = F("Ash");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}
		else {
			dir_sub = String(season_week);
			dir_day = (FPSTR(WeekDays[day]));
			// Need to handle Vigil Mass (Holy Saturday after sunset). 
			// Holy Saturday (before the Vigil) is in Lent/6/Saturday/. Easter Vigil Mass is in Easter/Vigil/, but is in (at the end of) Lent season, so it would be done here
		}
		break;

	case SEASON_EASTER:
		dir_season = F("Easter");

		if (season_week == 0) {
			// in Easter week
			dir_day = (FPSTR(WeekDays[day]));
		}
		else {
			int week_after_easter = season_week;
			if (bSunday) { // file directories are weeks *after* easter, hence Easter/1/ = Second Week of Easter or 1st Week After Easter, so subtract 1 to season_week
				if (week_after_easter >= 1 && week_after_easter <= 5) {
					dir_sub = String(week_after_easter);
					dir_day = F("Sunday");
				}

				if (week_after_easter == 6) {
					dir_season = F("Ascension"); // Seventh Sunday after Easter Sunday is Sunday after the Ascension
					dir_day = F("Sunday");
				}
			}
			else { // if not a Sunday
				if (week_after_easter >= 1 && week_after_easter <= 4) {
					dir_sub = String(week_after_easter);
					dir_day = F("Sunday"); // feria of Paschaltide if no feast on the same day (use the Sunday Mass for the Sunday of that week)
					bOverrideIfFeast = true;
				}

				if (week_after_easter == 5) { // season_week is the week number of easter, 6th week of Easter is 5th week after Easter week
					switch (day) {
					case PY_MON:
					case PY_TUE:
						dir_sub = F("5"); // rogation days in Easter
						dir_day = F("Rogation");
						break;

					case PY_WED:
						dir_sub = F("5"); // rogation days in Easter
						dir_day = F("Rogation");
						// Day before Ascension Thursday is also the Vigil of the Ascension (after sunset?). Support for this should be added here
						break;

					case PY_THU:
						dir_season = F("Ascension"); // Ascension Thursday
						dir_day = F("Thursday");
						break;

					case PY_FRI: // Friday after Ascension, may be feria of Ascension if no feast day
						dir_season = F("Ascension");
						dir_day = F("Feria");
						bOverrideIfFeast = true;
						break;
					}
				}

				if (week_after_easter == 6) {
					// feria of Ascension
					dir_season = F("Ascension");
					dir_day = F("Feria");
					bOverrideIfFeast = true;
				}
			}
		}
		break;

	case SEASON_PENTECOST:
		dir_season = F("Pentecost");

		if (datetime >= Pentecost(year) && datetime < TrinitySunday(year)) {
			if (bSunday) {
				dir_day = F("Sunday");
			}
			else {
				dir_sub = F("Whit");
				dir_day = (FPSTR(WeekDays[day]));
			}
			break;
		}
		break;

	case SEASON_AFTER_PENTECOST:
		// from the first week after Pentecost up to the beginning of Advent in the next Liturgical year
		dir_season = F("Pentecost");

		if (issameday(datetime, TrinitySunday(year))) {
			dir_day = F("TrinitySunday");
			break;
		}

		if (issameday(datetime, CorpusChristi(year))) {
			dir_day = F("CorpusChristi");
			break;
		}

		if (issameday(datetime, SacredHeart(year))) {
			dir_day = F("SacredHeartofJesus");
			break;
		}

		if (IsEmberDay(datetime)) { // Ember days of Pentecost season (in September)
			dir_sub = F("Ember");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}

		if (issameday(datetime, ChristTheKing(year))) {
			dir_day = F("ChristusRex");
			break;
		}

//		if (bSunday) {
//			dir_sub = String(season_week);
//			dir_day = "Sunday";
//			break;
//		}

		if (bSunday) {
			uint8_t after_pentecost_numweeks = Season_Week(first_advent_sunday(year) - SECS_PER_WEEK, season);
			if (issameday(sunday_after(datetime), first_advent_sunday(year))) {
				dir_sub = F("Last");		// Last Sunday of Pentecost
				dir_day = F("Sunday");
			}
			else {
				if (season_week > 23) {	// Epiphany resumed
					int epiphany_resumed_week = season_week + 7 - after_pentecost_numweeks;
					dir_season = F("Epiphany");
					dir_sub = F("Resumed");
					dir_subsub = String(epiphany_resumed_week);
					dir_day = F("Sunday");
				}
				else {
					dir_sub = String(season_week);
					dir_day = F("Sunday");
					break;
				}
			}
		}
		else {
			uint8_t after_pentecost_numweeks = Season_Week(first_advent_sunday(year) - SECS_PER_WEEK, season);
			if (season_week > 23) {	// Epiphany resumed
				int epiphany_resumed_week = season_week + 7 - after_pentecost_numweeks;
				dir_season = F("Epiphany");
				dir_sub = F("Resumed");
				dir_subsub = String(epiphany_resumed_week);
				dir_day = (FPSTR(WeekDays[day]));
			}
			else {
				dir_sub = String(season_week);
				dir_day = (FPSTR(WeekDays[day]));
			}
		}
		break;

	default:
		break;
	}

    //String filename = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("/title_en.txt"));
	DEBUG_PRT.print(F(" 1"));
    FileDir_Saint = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("/"));
	DEBUG_PRT.print(F(" 2"));

	if (dir_day == "" || (bOverrideIfFeast && SD.exists(FileDir_Saint))) { //FileExists(filename))) {
		dir_season = String(month_of_year);
		dir_sub = "";
		dir_subsub = "";
		dir_day = String(day_of_month);
	}
	DEBUG_PRT.print(F(" 3"));

	FileDir_Season = String(F("/")) + dir_season + String(F("/")) + dir_sub + String(F("/")) + dir_subsub + String(F("/")) + dir_day + String(F("/"));
	FileDir_Season.replace(String(F("///")), String(F("/")));
	FileDir_Season.replace(String(F("//")), String(F("/")));
	DEBUG_PRT.println(F(" 4"));
	//printf("FileDir_Season = %s\n", FileDir.c_str());
}


bool Tridentine::IsPassionWeek(time64_t datetime) 
{
	// PLL-01-06-2021 Work around for bug in Divinum Officium (version I used) that made days of Holy Week Class IV instead of Class III/Semiduplex
	
	time64_t palm_sunday = PalmSunday(year(datetime));

	return (datetime >= (palm_sunday - SECS_PER_WEEK) && datetime < palm_sunday);
}

bool Tridentine::IsHolyWeek(time64_t datetime)
{
	time64_t palm_sunday = PalmSunday(year(datetime));

	return (datetime >= palm_sunday && datetime < (palm_sunday + SECS_PER_WEEK));
}
/*
#define MASS_TRIDENTINE_1570 1
#define MASS_TRIDENTINE_1910 2
#define MASS_DIVINEAFFLATU 3
#define MASS_1955 4
#define MASS_1960 5
*/

#ifdef TRANSFERS_OLDCODE
#ifndef _WIN32
String Tridentine::strDeferredFeastFilename = ""; // initialize deferred feast filename
String Tridentine::strDeferredFeastImageFilename = ""; // initialize deferred feast image filename
#else
String Tridentine::strDeferredFeastFilename[5]; // initialize deferred feast filename
String Tridentine::strDeferredFeastImageFilename[5]; // initialize deferred feast image filename

int Tridentine::getTrIndex(String& FileDir_df) {
	int trIndex = -1;
	if (FileDir_df.indexOf("1570") != -1) { trIndex = 0; }
	if (FileDir_df.indexOf("1910") != -1) { trIndex = 1; }
	if (FileDir_df.indexOf("Affl") != -1) { trIndex = 2; }
	if (FileDir_df.indexOf("1955") != -1) { trIndex = 3; }
	if (FileDir_df.indexOf("1960") != -1) { trIndex = 4; }

	return trIndex;
}
#endif

#ifndef _WIN32
bool Tridentine::getDeferredFeast(String& FileDir_df, String& ImageFilename_df) {
	String deferredFilename = Tridentine::strDeferredFeastFilename;
	String deferredImageFilename = Tridentine::strDeferredFeastImageFilename;
#else
bool Tridentine::getDeferredFeast(String& FileDir_df, String& ImageFilename_df, String lect) {
	int trIndex = getTrIndex(lect);
	String deferredFilename = trIndex != -1 ? Tridentine::strDeferredFeastFilename[trIndex] : "";
	String deferredImageFilename = trIndex != -1 ? Tridentine::strDeferredFeastImageFilename[trIndex] : "";
#endif

	if (deferredFilename != "") {
		DEBUG_PRT.print(F("getDeferredFeast(): deferred feast filename = ["));
		DEBUG_PRT.print(deferredFilename);
		DEBUG_PRT.println(F("]"));
		DEBUG_PRT.print(F("getDeferredFeast(): deferred feast image filename = ["));
		DEBUG_PRT.print(deferredImageFilename);
		DEBUG_PRT.println(F("]"));

#ifdef _WIN32
		Tridentine::strDeferredFeastFilename[trIndex] = ""; // clear deferred filename once used **testing/temporary - since will be used more than once in real usage
		Tridentine::strDeferredFeastImageFilename[trIndex] = ""; // clear deferred image filename once used **testing/temporary - since will be used more than once in real usage
		Bidi::printf("<span style='color:violet; background-color:lightgray;'>getDeferredFeast(): [%s][%s][%d]</span>", deferredFilename.c_str(), deferredImageFilename.c_str(), trIndex);
#endif
	}
	else {
		DEBUG_PRT.println(F("getDeferredFeast(): no deferred feast"));

#ifdef _WIN32
		Bidi::printf("<span style='color:violet; background-color:lightgray;'>getDeferredFeast(): no deferred feast</span>");
#endif
	}

	FileDir_df = deferredFilename;
	ImageFilename_df = deferredImageFilename;
	return (deferredFilename != "");
}

bool Tridentine::setDeferredFeast(String FileDir_df, String ImageFilename_df, String lect) {
	DEBUG_PRT.print(F("setDeferredFeast(): called with FileDir_df = ["));
	DEBUG_PRT.print(FileDir_df);
	DEBUG_PRT.print(F("] and ImageFilename_df = ["));
	DEBUG_PRT.print(ImageFilename_df);
	DEBUG_PRT.println(F("]"));

#ifndef _WIN32
	String deferredFilename = Tridentine::strDeferredFeastFilename;
#else
	int trIndex = getTrIndex(lect);
	if (trIndex == -1) return false;
	String deferredFilename = Tridentine::strDeferredFeastFilename[trIndex];
#endif

	if (deferredFilename != "") {
		DEBUG_PRT.print(F("setDeferredFeast(): already have a deferred feast filename set ( = ["));
		DEBUG_PRT.print(deferredFilename);
		DEBUG_PRT.println(F("], clear it first"));
#ifdef _WIN32
		Bidi::printf("<span style='color:violet; background-color:lightgray;'>setDeferredFeast(): deferred feast is already set [%s][%d], clear it first</span>", deferredFilename.c_str(), trIndex);
#endif
		return false;
	}
	
#ifndef _WIN32
	Tridentine::strDeferredFeastFilename = FileDir_df;
	Tridentine::strDeferredFeastImageFilename = ImageFilename_df;
#else
	Tridentine::strDeferredFeastFilename[trIndex] = FileDir_df;
	Tridentine::strDeferredFeastImageFilename[trIndex] = ImageFilename_df;
#endif

	if (FileDir_df != "") {
		DEBUG_PRT.print(F("setDeferredFeast(): set deferred feast filename to = ["));
		DEBUG_PRT.print(FileDir_df);
		DEBUG_PRT.print(F("] and ImageFilename_df = ["));
		DEBUG_PRT.print(ImageFilename_df);
		DEBUG_PRT.println(F("]"));

#ifdef _WIN32
		Bidi::printf("<span style='color:violet; background-color:lightgray;'>setDeferredFeast(): deferred feast now set to [%s][%s][%d]</span>", FileDir_df.c_str(), ImageFilename_df.c_str(), trIndex);
#endif

		return true;
	}
	
	DEBUG_PRT.print(F("setDeferredFeast(): cleared deferred feast filename"));
#ifdef _WIN32
	Bidi::printf("<span style='color:violet; background-color:lightgray;'>setDeferredFeast(): cleared deferred feast filename [%d]</span>", trIndex);
#endif

	return false;
}

#ifndef _WIN32
bool Tridentine::clearDeferredFeast() {
	Tridentine::strDeferredFeastFilename = ""; // clear deferred filename once used **testing/temporary - since will be used more than once in real usage
	Tridentine::strDeferredFeastImageFilename = ""; // clear deferred image filename once used **testing/temporary - since will be used more than once in real usage
	return true;
}
#else
bool Tridentine::clearDeferredFeast(String lect) {
	int trIndex = getTrIndex(lect);
	if (trIndex != -1) {
		Tridentine::strDeferredFeastFilename[trIndex] = ""; // clear deferred filename once used **testing/temporary - since will be used more than once in real usage
		Tridentine::strDeferredFeastImageFilename[trIndex] = ""; // clear deferred image filename once used **testing/temporary - since will be used more than once in real usage
		DEBUG_PRT.println(F("clearDeferredFeast() deferred feast cleared"));
		Bidi::printf("clearDeferredFeast() OK [%d]\n", trIndex);
		return true;
	}
	DEBUG_PRT.println(F("clearDeferredFeast() deferred feast not found"));
	Bidi::printf("clearDeferredFeast() Feast not found [%d]\n", trIndex);
	return false;
}
#endif
#endif

String Tridentine::getImageFilenameFromFileDir(String filedir, String lect_fileroot, String lect_imageroot) { // lect_fileroot should include the lang part of the path (eg 1955/en/)
	// reverse calculate the image filename from the Missalreading filedir (used for finding image name when a deferred feast is being celebrated)
	// works for /m/d/ type filedir values
	String imagefn = "";

	int lectfilerootindex = filedir.indexOf(lect_fileroot);
	//if (lectfilerootindex != 0) return imagefn;
	if (lectfilerootindex != -1) {
		imagefn = filedir.substring(lect_fileroot.length());
	}
	else {
		imagefn = filedir;
	}
	int offset_day = imagefn.indexOf(F("/"), 1);
	String month_of_year = imagefn.substring(1, offset_day);	// is of the form /12/24/ (where 12 is the month)
	String day_of_month = imagefn.substring(offset_day + 1, imagefn.lastIndexOf(F("/")));
	if (day_of_month.toInt() != 0 && month_of_year.toInt() != 0) {
		return String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("-")) + String(month_of_year);
	}
#ifdef _WIN32
	Bidi::printf("getImageFilenameFromFileDir() WARN (probably won't work!): returning [%s]", imagefn);
#endif
	DEBUG_PRT.print(F("getImageFilenameFromFileDir() WARN (probably won't work!): returning "));
	DEBUG_PRT.println(imagefn);

	return imagefn; // *** PLL-17-10-2024 TODO: Need to make this function return correct values for filenames for Feasts of the Lord, which it will not do yet
}

int8_t Tridentine::GetLectionaryVersionNumber(String& FileDir_df) {
	int lectnum = -1;

	if (FileDir_df.indexOf("1570") != -1) { lectnum = MASS_TRIDENTINE_1570; }
	else if (FileDir_df.indexOf("1910") != -1) { lectnum = MASS_TRIDENTINE_1910; }
	else if (FileDir_df.indexOf("DivAffla") != -1) { lectnum = MASS_DIVINEAFFLATU; }
	else if (FileDir_df.indexOf("1955") != -1) { lectnum = MASS_1955; }
	else if (FileDir_df.indexOf("1960") != -1) { lectnum = MASS_1960; }
	else if (FileDir_df.indexOf("1960New") != -1) { lectnum = MASS_1960NEW; }
	else if (FileDir_df.indexOf("1965-67") != -1) { lectnum = MASS_1965_67; }

	return lectnum;
}

#define MASS_TRIDENTINE_1570 1
#define MASS_TRIDENTINE_1910 2
#define MASS_DIVINEAFFLATU 3
#define MASS_1955 4
#define MASS_1960 5
#define MASS_1960NEW 6
#define MASS_1965_67 7


void Tridentine::GetFileDir2(
	time64_t datetime,
	String& FileDir_Season, String& FileDir_Saint, String& FileDir_Votive,
	bool& HolyDayOfObligation,
	String& SeasonImageFilename, String& SaintImageFilename, String& VotiveImageFilename, /*String& DeferredImageFilename,*/
	uint8_t MassType) {

	DEBUG_PRT.print(F("Tridentine::GetFileDir2():"));

	bool bSaturday = (weekday(datetime) == PY_SAT); // for Saturday of Our Lady Votive Masses
	bool bSunday = sunday(datetime);
	HolyDayOfObligation = bSunday;

	int year = ::year(datetime);
	
	int day_of_month = dayofmonth(datetime);
	int month_of_year = monthofyear(datetime);
	int day = weekday(datetime, true);

	FileDir_Season = "";
	FileDir_Saint = "";
	
	String ImageFilename = "";
	SeasonImageFilename = "";
	SaintImageFilename = "";
	VotiveImageFilename = "";
	//DeferredImageFilename = "";

#ifdef _WIN32
	Tridentine::print_season = true;
#endif
	uint8_t season = Season(datetime);
	uint8_t season_week = Season_Week(datetime, season);
#ifdef _WIN32
	Tridentine::print_season = false;
#endif

	uint8_t octave_daynumber = 0;

	bool bOverrideIfFeast = false; // if set, then the string in the variable fd will be used as the directory name only if there is no feast day on the same day (these are the month/day folders, eg 1962/01/05/)
	bool bSuppressFeast = false;   // All Souls needs a sub directory (1, 2 or 3) for the masses of the day, and falls on 11/2, which is the dir it is stored in. This flag suppresses the use of the FileDir_Saint directory string, so that the subdir can be added to the FileDir_Season string

	String dir_season = "";
	String dir_sub = "";
	String dir_subsub = "";
	String dir_day = "";

	String votive_dir_season = "";
	String votive_dir_sub = "";
	String votive_dir_day = "";

	if (bSaturday) {
		votive_dir_season = F("Votive");
		votive_dir_sub = F("OurLady");
		votive_dir_day = F("1");
		VotiveImageFilename = F("OurLady");

		if (season == SEASON_ADVENT) {
			votive_dir_day = F("a"); // Saturday of Our Lady in Advent
		}
		else if (monthofyear(datetime) == 1 || (monthofyear(datetime) == 2 && dayofmonth(datetime) == 1)) {
			votive_dir_day = F("b"); // between Holy Family up to 1st Feb inclusive
		}
		else if (datetime < (MaundyThursday(year))) {
			votive_dir_day = F("c"); // between 3rd Feb and Spy Wednesday
		}
		else if (season == SEASON_EASTER) {
			votive_dir_day = F("Pasc");
		}
		else if (datetime > TrinitySunday(year)) {
			votive_dir_day = F("t"); // between Trinity Sunday and Advent
		}
		
		VotiveImageFilename = VotiveImageFilename + String(F("-")) + votive_dir_day;
	}
/*
      $dir_day =
          ($dayname[0] =~ /Adv/i) ? "a"
        : ($month == 1 || ($month == 2 && $day == 1)) ? "b"
        : ($dayname[0] =~ /(Epi|Quad)/i) ? "c"
        : ($dayname[0] =~ /Pasc/i) ? "Pasc"
        : "1";
*/
	DEBUG_PRT.print(F("0 "));

	// The Six Holy Days (per https://lms.org.uk/sites/default/files/resource_documents/fiuv/fiuv_pp_13_holy_days_of_obligation.pdf p9)

	bool bIsStJosephSponsiTransferred = false;

	if (issameday(datetime, StJoseph(year))) { 
		HolyDayOfObligation = true; 
		if (!(issameday(datetime, date(19, 3, year)))) { // was transferred if not 19th March (happened in 2023)
			bIsStJosephSponsiTransferred = true;
			FileDir_Saint = String(F("/3/19/"));
			SaintImageFilename = String(F("/3/19-3"));

		}
	}

	if (issameday(datetime, date(1, 1, year))) { HolyDayOfObligation = true; } // 07-01-2023 Octave day of Christmas is always Holy Day of Obligation.
	if (issameday(datetime, ImmaculateConception(year))) { HolyDayOfObligation = true; } // 07-01-2023 Immaculate Conception is always Holy Day of Obligation.
	if (issameday(datetime, AssumptionOfMary(year))) { HolyDayOfObligation = true; } // 07-01-2023 Assumption of Mary is always Holy Day of Obligation.
	if (issameday(datetime, MartyrdomOfSSPeterAndPaul(year))) { HolyDayOfObligation = true; } // per https://lms.org.uk/sites/default/files/resource_documents/fiuv/fiuv_pp_13_holy_days_of_obligation.pdf p9
	if (issameday(datetime, AllSaints(year))) { HolyDayOfObligation = true; } // 07-01-2023 All Saints is a Holy Day of Obligation.
	// Epiphany, Corpus Christi and Ascension Day are handled in the code below

	switch (season) {
	case SEASON_ADVENT:
		//fd = "Advent/";
		dir_season = F("Advent");
		if (IsEmberDay(datetime)) {
			dir_sub = F("Ember");
		}
		else {
			dir_sub = String(season_week);
		}
		dir_day = (FPSTR(WeekDays[day]));
		break;

	case SEASON_CHRISTMAS:
		dir_season = F("Christmas");

		if (issameday(datetime, nativity(year))) { // Christmas Day
			dir_sub = F("Day");
			//dir_day = F("1");	// 1, 2 or 3

			int8_t hour = ::hour(datetime);
			if (hour >= 0 && hour < 6) {
				dir_day = F("1"); // readings from midnight mass
			}
			else if (hour >= 6 && hour < 11) {
				dir_day = F("2"); // readings from mass at dawn
			}
			else {
				dir_day = F("3"); // readings from mass during the day
			}

			HolyDayOfObligation = true;
			
			ImageFilename = F("Nativity");
			break;
		}

		if (MassType > MASS_TRIDENTINE_1570 && issameday(datetime, HolyName(year))) {
			dir_day = F("HolyName");
			break;
		}

		if (bSunday && !issameday(datetime, nativity(year)) && datetime > nativity(year) && datetime < date(1, 1, year + 1)) {
			// Sunday in the Octave of Christmas
			dir_day = F("Sunday");
			break;
		}

		if (!bSunday && datetime > date(1, 1, year) && datetime < HolyName(year)) {
			//dir_day = F("Feria");
			bOverrideIfFeast = true;
		}
		break;

	case SEASON_EPIPHANY:
		// Holy Family is the first Sunday after Epiphany. The 1st Sunday Mass is celebrated on Feria during the season of Epiphany (if there is no Feast day on that day)
		if (issameday(datetime, HolyFamily(year))) {
			dir_season = F("Christmas");
			dir_day = F("HolyFamily");
			break;
		}

		if (issameday(datetime, Epiphany(year))) {
			bOverrideIfFeast = true;	// date is fixed, 6 Jan
			HolyDayOfObligation = true; 
			break;
		}

		DEBUG_PRT.print(F("Epiphany: season_week is "));
		DEBUG_PRT.println(season_week);

		if (datetime < sunday_after(Epiphany(year))) {
			season_week = 0;
		}
/*
		if(season_week > 0 && !sunday(Epiphany(year))) { // if Epiphany is on a Sunday, week including the Sunday will be calculated as week 0. If Epiphany is not on a 
			season_week -= 1;							 // Sunday, the first week will be calculated as week 1 (this fixes this for Epiphany)
		
			DEBUG_PRT.print(F("Epiphany is on a sunday and season_week is "));
			DEBUG_PRT.println(season_week);	
		}
*/

		DEBUG_PRT.print(F("Epiphany, after processing, season_week is "));
		DEBUG_PRT.println(season_week);	

		if (season_week > 0) {	// Weekdays of the days after Epiphany before the following Sunday (if Epiphany is not itself on a Sunday) are given as dates, eg Die Septima Januarii
			DEBUG_PRT.print(F("Setting Epiphany season/sub/day for season week"));
			dir_season = F("Epiphany");
			dir_sub = String(season_week);
			dir_day = (FPSTR(WeekDays[day]));
		}
		break;

	case SEASON_SEPTUAGESIMA:
		if (datetime >= Septuagesima(year) && datetime < Sexagesima(year)) {
		//if (issameday(datetime, Septuagesima(year))) {
			dir_season = F("Septuagesima");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}

		if (datetime >= Sexagesima(year) && datetime < Quinquagesima(year)) {
		//if (issameday(datetime, Sexagesima(year))) {
			dir_season = F("Sexagesima");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}

		if (datetime >= Quinquagesima(year) && datetime < AshWednesday(year)) {
		//if (issameday(datetime, Quinquagesima(year))) {
			dir_season = F("Quinquagesima");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}
		break;

	case SEASON_LENT:
		// PLL-14-12-2020
		if (issameday(datetime, AshWednesday(year))) { HolyDayOfObligation = true; ImageFilename = F("AshWednesday"); }
		if (issameday(datetime, GoodFriday(year))) { HolyDayOfObligation = true; ImageFilename = F("GoodFriday"); }
		if (issameday(datetime, MaundyThursday(year))) { ImageFilename = F("MaundyThursday"); }
		if (issameday(datetime, PalmSunday(year))) { ImageFilename = F("PalmSunday"); }
		// PLL-14-12-2020

		if (datetime >= (AshWednesday(year) /*+ SECS_PER_DAY*/) && datetime < sunday_after(AshWednesday(year))) {
			// Lent begins on Ash Wednesday, but Ash Wednesday and days after ashes occur in the week of Quinquagesima, so are stored in that folder
			dir_season = F("Quinquagesima");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}

		dir_season = F("Lent");
		dir_sub = String(season_week);
		dir_day = (FPSTR(WeekDays[day]));
		// Need to handle Vigil Mass (Holy Saturday after sunset). 
		// Holy Saturday (before the Vigil) is in Lent/6/Saturday/. Easter Vigil Mass is in Easter/Vigil/, but is in (at the end of) Lent season, so it would be done here
		break;

	case SEASON_EASTER:
		dir_season = F("Easter");
		
		if(season_week == 0) {
			// Octave of Easter
			ImageFilename = String(F("Easter")) + String(FPSTR(WeekDays[day]));
		}

		// PLL-14-12-2020
		if (issameday(datetime, Easter(year))) { ImageFilename = F("EasterSunday"); }
		if (issameday(datetime, Ascension(year))) { ImageFilename = F("AscensionThursday"); HolyDayOfObligation = true;}
		// PLL-14-12-2020

		if (issameday(datetime, sunday_after(Easter(year)))) { ImageFilename = F("OctaveDayOfEaster"); }

		if (season_week < 7) {
			dir_sub = String(season_week);
			dir_day = (FPSTR(WeekDays[day]));
		}
		break;

	case SEASON_PENTECOST: 
		dir_season = F("Pentecost");

		// PLL-14-12-2020
		if (issameday(datetime, Pentecost(year))) { ImageFilename = F("PentecostSunday"); }
		// PLL-14-12-2020

		if (datetime >= Pentecost(year) && datetime < TrinitySunday(year)) {
			if (bSunday) {
				dir_day = F("Sunday");
			}
			else {
				dir_sub = F("Whit");
				dir_day = (FPSTR(WeekDays[day]));
			}
			break;
		}
		break;

	case SEASON_AFTER_PENTECOST:
		// from the first week after Pentecost up to the beginning of Advent in the next Liturgical year
		dir_season = F("Pentecost");

		if (issameday(datetime, TrinitySunday(year))) {
			// PLL-14-12-2020
			ImageFilename = F("TrinitySunday");
			// PLL-14-12-2020
			dir_day = F("TrinitySunday");
			break;
		}

		if (issameday(datetime, CorpusChristi(year))) {
			// PLL-14-12-2020
			ImageFilename = F("CorpusChristi");
			// PLL-14-12-2020
			dir_day = F("CorpusChristi");
			HolyDayOfObligation = true;
			break;
		}

		if (issameday(datetime, SacredHeart(year))) {
			// PLL-14-12-2020
			ImageFilename = F("SacredHeart");
			// PLL-14-12-2020
			dir_day = F("SacredHeartofJesus");
			HolyDayOfObligation = true;
			break;
		}

		if (IsEmberDay(datetime)) { // Ember days of Pentecost season (in September)
			dir_sub = F("Ember");
			dir_day = (FPSTR(WeekDays[day]));
			break;
		}
		/*
		if (MassType > MASS_TRIDENTINE_1910 && issameday(datetime, ChristTheKing(year))) {
			// PLL-14-12-2020
			ImageFilename = F("ChristusRex");
			// PLL-14-12-2020
			dir_day = F("ChristusRex");
			break;
		}
		*/
		/*
		if (issameday(datetime, AllSouls(year))) {
			dir_season = F("11");	// 11/2/[1 2 or 3]. (There are 3 masses during All Souls day)
			dir_sub = F("2");
			int8_t hour = ::hour(datetime);
			if (hour >= 0 && hour < 6) {
				dir_day = F("1"); // readings from night mass
			}
			else if (hour >= 6 && hour < 11) {
				dir_day = F("2"); // readings from morning mass
			}
			else {
				dir_day = F("3"); // readings from mass during the day
			}

			bSuppressFeast = true;
			break;
		}
		*/
//		if (bSunday) {
//			dir_sub = String(season_week);
//			dir_day = "Sunday";
//			break;
//		}

		if (bSunday) {
			uint8_t after_pentecost_numweeks = Season_Week(first_advent_sunday(year) - SECS_PER_WEEK, season);
			if (issameday(sunday_after(datetime), first_advent_sunday(year))) {
				dir_sub = F("Last");		// Last Sunday of Pentecost
				dir_day = F("Sunday");
			}
			else {
				if (season_week > 23) {	// Epiphany resumed
					int epiphany_resumed_week = season_week + 7 - after_pentecost_numweeks;
					dir_season = F("Epiphany");
					dir_sub = F("Resumed");
					dir_subsub = String(epiphany_resumed_week);
					dir_day = F("Sunday");
				}
				else {
					dir_sub = String(season_week);
					dir_day = F("Sunday");
					break;
				}
			}
		}
		else {
			uint8_t after_pentecost_numweeks = Season_Week(first_advent_sunday(year) - SECS_PER_WEEK, season);
			if ((first_advent_sunday(year) - datetime) < SECS_PER_WEEK) {	// 24th and Last week of Pentecost
				dir_sub = F("Last");		// Last Sunday of Pentecost
				dir_day = FPSTR(WeekDays[day]);
			}
			else 
			{
				if (season_week > 23) {	// Epiphany resumed
					int epiphany_resumed_week = season_week + 7 - after_pentecost_numweeks;
					dir_season = F("Epiphany");
					dir_sub = F("Resumed");
					dir_subsub = String(epiphany_resumed_week);
					dir_day = (FPSTR(WeekDays[day]));
				}
				else {
					dir_sub = String(season_week);
					dir_day = (FPSTR(WeekDays[day]));
				}
			}
		}
		break;

	default:
		break;
	}

	bool bIsLadyDay = issameday(datetime, LadyDay(year));
	if (bIsLadyDay) {
		FileDir_Saint = String(F("/3/25/")); 	// Lady Day is moveable, but get the devotional image and Mass Propers from March 25th, it's default date
		SaintImageFilename = String(F("/3/25-3"));
	}
	else {
		if (month_of_year == 3 && day_of_month == 25) { // is 25th of March, but not Lady Day, so it has been moved
			bSuppressFeast = true;						// so don't fetch the Feast Propers for this day
		}
	}

    //String filename = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("/title_en.txt"));
	DEBUG_PRT.print(F(" 1"));

	if (!bSuppressFeast) {
		if (!bIsLadyDay && !bIsStJosephSponsiTransferred) // filedir is precalculated to take account of transferred date if so, so don't overwrite with default
		{
			FileDir_Saint = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("/"));
		}

		bool bIsStMatthiasDayInLeapYear = false;

		if (isleap(year)) {
			if (month_of_year == 2 && (day_of_month == 24 || day_of_month == 27)) {
				FileDir_Saint = "";	// skip St Matthias day on 24th Feb if a leap year, as it is celebrated on the 25th, or St Gabrielis Day on Feb 27th, which also is transferred a day later
				SaintImageFilename = "";
				bIsStMatthiasDayInLeapYear = true;
			}

			if (month_of_year == 2 && day_of_month == 25) {
				FileDir_Saint = String(F("/2/24/")); // Handle St Matthias day in leap years, which falls on 25th Feb instead of 24th Feb, so get Propers for 25th from 2/24 in this case
				SaintImageFilename = String(F("/2/24-2"));
			}

			if (month_of_year == 2 && day_of_month == 28) {
				FileDir_Saint = String(F("/2/27/")); // Handle St Gabrielis day in leap years, which falls on 28th Feb instead of 27th Feb, so get Propers for 28th from 2/27 in this case
				SaintImageFilename = String(F("/2/27-2"));
			}
		}

		bool bIsChristusRex = issameday(datetime, ChristTheKing(year));
		if (bIsChristusRex && MassType > MASS_TRIDENTINE_1910) {
			SaintImageFilename = F("ChristusRex");
			FileDir_Saint = F("/Pentecost/ChristusRex/");
		}

		if (issameday(datetime, AllSouls(year))) {
			FileDir_Saint = String(F("/11/2/"));
			int8_t hour = ::hour(datetime);
			String massnumber = "";
			if (hour >= 0 && hour < 6) {
				massnumber = F("1"); // readings from night mass
			}
			else if (hour >= 6 && hour < 11) {
				massnumber = F("2"); // readings from morning mass
			}
			else {
				massnumber = F("3"); // readings from mass during the day
			}
			FileDir_Saint = FileDir_Saint + massnumber + String(F("/"));
			SaintImageFilename = String(F("/11/2"));
		}

		if (ImageFilename == "" && !bIsStMatthiasDayInLeapYear && !bIsLadyDay && !bIsChristusRex && !bIsStJosephSponsiTransferred) { // If St Matthias' Day, Lady Day or St Joseph Sponsi (if transferred), the SaintImageFilename will already have been set appropriately
			SaintImageFilename = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("-")) + String(month_of_year);
		}
		else { // PLL-14-12-2020
			if (!bIsChristusRex) {
				SeasonImageFilename = String(F("/Temporal/")) + ImageFilename;	// prepend Temporal folder for Easter and other moveable feasts that depend on it etc.
			}
			else {
				// PLL-30-10-2022 ChristusRex is handled as a Feast, but, the Mass data is stored in the Pentecost/ folder (under Pentecost/ChristusRex/, however it is treated as a Feast, as if it were a Calendar feast (as if it were in MM/DD folder))
				SaintImageFilename = String(F("/Temporal/")) + SaintImageFilename;	// PLL-30-10-2022 Christ the King is handled as a Feast, as if it were in the MM/DD folders, but is actually under Pentecost
			}
		} // PLL-14-12-2020
	}
	DEBUG_PRT.print(F(" 2"));

	if (dir_day == "" || (bOverrideIfFeast && SD.exists(FileDir_Saint))) { //FileExists(filename))) {
		dir_season = String(month_of_year);
		dir_sub = "";
		dir_subsub = "";
		dir_day = String(day_of_month); // wonder what might happen on St Matthias' day in a leap year if bOverrideIfFeast gets set. I don't think it can happen though
		if (ImageFilename == "") {
			SaintImageFilename = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("-")) + String(month_of_year);
		}
		//else {
		//	DeferredImageFilename = String(F("/")) + String(month_of_year) + String(F("/")) + String(day_of_month) + String(F("-")) + String(month_of_year);
		//}
	}

	FileDir_Votive = "";
	if (votive_dir_season != "") {
		FileDir_Votive = String(F("/")) + votive_dir_season + String(F("/")) + votive_dir_sub + String(F("/")) + votive_dir_day;
		VotiveImageFilename = String(F("/Votive/")) + VotiveImageFilename;
	}

	DEBUG_PRT.print(F(" 3"));

	FileDir_Season = String(F("/")) + dir_season + String(F("/")) + dir_sub + String(F("/")) + dir_subsub + String(F("/")) + dir_day + String(F("/"));
	FileDir_Season.replace(String(F("///")), String(F("/")));
	FileDir_Season.replace(String(F("//")), String(F("/")));
	DEBUG_PRT.println(F(" 4"));
	//printf("FileDir_Season = %s\n", FileDir.c_str());
}

/*
bool Tridentine::FileExists(String filename) {
	FILE* fp = fopen(filename.c_str(), "rb");

	if (fp != NULL) {
		fclose(fp);
		return true;
	}
	return false;
}
*/

void Tridentine::GetMassAndCommFromTrFixedFeast(Tr_Fixed_Feast& trff, String& Mass, String& Commemoration, uint8_t season, uint8_t day_class) {
	if (trff.bMassIsCommemoration || (season == SEASON_LENT && day_class <= trff.Class)) { // in lent, feasts become commemorations
		// both strings in trff are for commemorations, so concatenate them
		Commemoration = trff.Mass;
		if (trff.bHasCommemoration) {
			Commemoration = Commemoration + ", " + trff.Commemoration;
		}
	}
	else {
		if (trff.bHasCommemoration) { // one Commemoration (if present)
			Commemoration = trff.Commemoration;
		}
		Mass = trff.Mass; // one Mass
	}
}

void Tridentine::HandleVotiveMasses(time64_t datetime, uint8_t& cls, uint8_t& col, String& Mass, String& Commemoration) {
	bool is_votive = false;
	HandleVotiveMasses(datetime, is_votive, cls, col, Mass, Commemoration);
}

void Tridentine::HandleVotiveMasses(time64_t datetime, bool& is_votive, uint8_t& cls, uint8_t& col, String& Mass, String& Commemoration) {
	/*
		Votive Masses

		ChristEternalPriest				celebrated on first Thursday or Saturday of month, 3rd Class
		SacredHeartOfJesus				celebrated on first Friday of month, 3rd Class
		ImmaculateHeartOfMary			celebrated on first Saturday of month, 3rd Class
		SaturdayOfOurLady				celebrated on all Saturdays which are 4th Class Feria
		MassForTheDeadInAllSoulsWeek	celebrated on any 3rd or 4th Class day between Nov 3rd to Nov 8th
		RorateCoeli						celebrate at the earliest opportunity after the configured day in Advent
	*/

	if (cls < 3) return;

	is_votive = true;

	bool bFirstThursday = firstday(PY_THU, datetime);
	bool bFirstFriday = firstday(PY_FRI, datetime);
	bool bFirstSaturday = firstday(PY_SAT, datetime);

	Yml i18n;
	String conf;
	String yml_path = F("tridentine.");
	String conf_path = F("config.celebrate_");
	String mass_path = F("votive.");

	if (bFirstThursday || bFirstSaturday) {
		String var = F("christ_priest");
		conf = i18n.get(yml_path + conf_path + var);
		if ((bFirstThursday && (conf == F("4") || conf == F("thursday"))) || (bFirstSaturday && (conf == F("6") || conf == F("saturday")))) {
			if (cls == 3) Commemoration = Mass; // if it is of the same class, make the currently Mass into a Commemoration
			Mass = i18n.get(yml_path + mass_path + var);
			cls = 3;
			col = TR_LIT_COLOUR_WHITE;
			return;
			// if Immaculate Heart of Mary is celebrated on the first Saturday and Christ Priest is also selects 
			// Saturday, Christ Priest will have priority, as this code is structured
		}
	}

	if (bFirstFriday) {
		String var = F("sacred_heart");
		conf = i18n.get(yml_path + conf_path + var);
		if (conf == F("true") || conf == F("1")) {
			if (cls == 3) Commemoration = Mass; // if it is of the same class, make the currently Mass into a Commemoration
			Mass = i18n.get(yml_path + mass_path + var);
			cls = 3;
			col = TR_LIT_COLOUR_WHITE;
			return;
		}
	}

	if (bFirstSaturday) {
		String var = F("immaculate_heart");
		conf = i18n.get(yml_path + conf_path + var);
		bool bIsImmaculateHeart = (conf == F("true") || conf == F("1"));
		
		if (!bIsImmaculateHeart) {
			var += F("_in_eastertide");
			conf = i18n.get(yml_path + conf_path + var);

			if (conf == F("true") || conf == F("1")) {
				time64_t first_saturday_of_month_afterLowSunday = QuasimodoSunday(year(datetime)) + 6 * SECS_PER_DAY;
				while (dayofmonth(first_saturday_of_month_afterLowSunday) > 7) {
					first_saturday_of_month_afterLowSunday += SECS_PER_WEEK;
				}
				if (issameday(datetime, first_saturday_of_month_afterLowSunday)) {
					bIsImmaculateHeart = true;
				}
			}
		}
		if (bIsImmaculateHeart) {
			if (cls == 3) Commemoration = Mass; // if it is of the same class, make the currently Mass into a Commemoration
			Mass = i18n.get(yml_path + mass_path + var);
			cls = 3;
			col = TR_LIT_COLOUR_WHITE;
			return;
		}
	}

	if (weekday(datetime) == PY_SAT && cls == 4) {
		String var = F("sat_of_our_lady");
		conf = i18n.get(yml_path + conf_path + var);
		if (conf == F("true") || conf == F("1")) {
			Mass = i18n.get(yml_path + mass_path + var);
			cls = 4;
			col = TR_LIT_COLOUR_WHITE;
			return;
		}
	}

	uint8_t dayofmonth = ::day(datetime);
	// between Nov 3rd and Nov 8th on Class 3 or 4 days
	if (cls >= 3 && ::month(datetime) == 11 && dayofmonth >= 3 && dayofmonth <= 8) {
		String var = F("mass_for_the_dead");
		conf = i18n.get(yml_path + conf_path + var);
		if (conf == F("true") || conf == F("1")) {
			Commemoration = ""; // do not celebrate Commemoration if Mass for the Dead is being said
			Mass = i18n.get(yml_path + mass_path + var);
			cls = 3;
			col = TR_LIT_COLOUR_BLACK;
			return;
		}
	}

	// rorate_coeli_in_advent
	// This Votive Mass will be celebrated on the configured day of advent, if
	// that day is a Feria of class 3 or 4 (since the first day of Advent is a Sunday,
	// the day of the Rorate Coeli mass can be selected so that it is certain to occur
	int year = ::year(datetime);
	time64_t fa_sunday = first_advent_sunday(year);
	if (datetime > fa_sunday && datetime < nativity(year)) { // cls is already 3 or 4 if we got here (checked at top of function)
		String var = F("rorate_coeli_in_advent");
		conf = i18n.get(yml_path + conf_path + var + F("_on_day"));
		if (conf != F("") && conf != F("false")) {
			int numdays = conf.toInt();
			if (numdays >= 0 && numdays <= 24) {
				time64_t earliest_datetime = fa_sunday + (numdays * SECS_PER_DAY);
				if (issameday(datetime, earliest_datetime)) {
					//if (cls == 3) Commemoration = Mass; // if it is of the same class, make the currently Mass into a Commemoration (does this apply in Advent, when Ferias are either class 3 or 2?)
					Mass = i18n.get(yml_path + mass_path + var);
					cls = 3;
					col = TR_LIT_COLOUR_WHITE;
					return;
				}
			}
		}
	}

	is_votive = false;
}

void Tridentine::get(time64_t datetime, Tr_Calendar_Day& td, bool doRogations) {
	int year = ::year(datetime);
	uint8_t season = Season(datetime);

	uint8_t col = TR_LIT_COLOUR_UNSET;
	uint8_t cls = 4;

	bool hdo = sunday(datetime);
	bool bSunday = sunday(datetime);
	bool feast_lord = false;

	String Mass = "";
	String Commemoration = "";

	ColourAndClass(datetime, doRogations, col, cls);
	
	String Mass_day = "";
	GetDay(datetime, Mass_day);

	bool bIsSet = false;

	bool is_feast_mf = false;
	uint8_t cls_mf = cls;
	uint8_t col_mf = col;
	bool hdo_mf = hdo;
	bool feast_lord_mf = false;
	String Mass_mf = "";
	String Commemoration_mf = "";
	bool bCommemorationOnly_mf = false;
	
	GetMoveableFeast(datetime, doRogations, is_feast_mf, cls_mf, col_mf, hdo_mf, feast_lord_mf, bCommemorationOnly_mf, Mass_mf, Commemoration_mf);
	if (is_feast_mf) {			
		if (cls_mf <= cls) {
			if (bCommemorationOnly_mf) {
				Mass = Mass_day;
			}
			else {
				Mass = Mass_mf;
			}
			Commemoration = Commemoration_mf;
			hdo = hdo_mf;
			cls = cls_mf;
			col = col_mf;
			bIsSet = true;
		}
		else if (cls == 1 && cls_mf == 2) {
			Commemoration = Mass_mf;
		}

	}
	if (!feast_lord_mf) {
		bool is_feast_ff = false;
		uint8_t cls_ff = cls;
		uint8_t col_ff = col;
		bool hdo_ff = hdo;
		bool feast_lord_ff = false;
		bool immaculate_conception = false;
		String Mass_ff = "";
		String Commemoration_ff = "";
		bool bCommemorationOnly_ff = false;
		
		GetFixedFeast(datetime, is_feast_ff, cls_ff, col_ff, hdo_ff, feast_lord_ff, immaculate_conception, bCommemorationOnly_ff, Mass_ff, Commemoration_ff);
		if (is_feast_ff) {
			bool bAssign = false;

			if (bSunday) {
				if (feast_lord_ff || immaculate_conception || (cls_ff < cls && !is_feast_mf) || (season == SEASON_AFTER_PENTECOST && cls_ff == cls)) { // sunday which can be replaced by a feast of the lord
					bAssign = true;
				}
			}
			else { // feria/weekday
				if ((!bCommemorationOnly_ff && cls_ff <= cls) || bCommemorationOnly_ff) { // commemmorations of lower rank can be held on a higher ranked day, eg Ferias of Advent
					bAssign = true;
				}
			}

			if (bAssign) {
				if (season != SEASON_LENT || (season == SEASON_LENT && cls_ff < cls)) {
					if (is_feast_mf && !bCommemorationOnly_ff) {
						Commemoration = Mass;
					}
					else if (cls_ff <= cls + 1) {
						Commemoration = Commemoration_ff;
					}
					
					if ((bSunday && cls_ff < cls && !feast_lord_ff) || (bSunday && immaculate_conception)) {
						Commemoration = Mass_day;
					}

					if (bSunday && cls_ff == cls && !feast_lord_ff && !immaculate_conception) {
						Commemoration = Mass_ff;
						Mass = Mass_day;
					}
					else if (!bCommemorationOnly_ff) {
						Mass = Mass_ff;
						hdo = hdo_ff;
						cls = cls_ff < cls ? cls_ff : cls;
					}
					else if (!is_feast_mf) {
						Mass = Mass_day;
					}
					col = col_ff == TR_LIT_COLOUR_UNSET ? col : col_ff; // the colour is the colour of the day if so
				}
				else {
					Mass = Mass_day;
					Commemoration = Mass_ff;
				}
				bIsSet = true;
			}
		}

		bool is_votive = false;
		uint8_t cls_vm = cls;
		uint8_t col_vm = col;
		String Mass_vm = Mass;
		String Commemoration_vm = Commemoration;
		GetVotiveMass(datetime, is_votive, cls_vm, col_vm, Mass_vm, Commemoration_vm);
		if (is_votive) {
			Mass = Mass_vm;
			Commemoration = Commemoration_vm;
			cls = cls_vm;
			col = col_vm;
			bIsSet = true;
		}

		if (!bIsSet) {
			Mass = Mass_day;
		}
	}
	// here, either the fixed feast will have set the class and colour, or the moveable feast - 
	// whichever has the lower class number (higher rank) will prevail. If neither prevail, then
	// the default colour and class for the Sunday (2) or Feria (4) will prevail.
	Yml i18n;
	String DayClass = i18n.get(String(F("class.")) + String(cls));
	String Colour = i18n.get(String(F("colour.")) + String(col));
	String DayofWeek = i18n.get(String(F("weekday.")) + String(weekday(datetime, false)));

	td.datetime = datetime;
	td.Cls = DayClass;
	td.Colour = Colour;
	td.DayofWeek = DayofWeek;
	td.Mass = Mass;
	td.Commemoration = Commemoration;
	td.HolyDayOfObligation = hdo;

	DEBUG_PRT.print(F("Tridentine::get() Calling GetFileDir()..."));
	GetFileDir(datetime, td.FileDir_Season, td.FileDir_Saint);
	DEBUG_PRT.println(F("done"));

#if(false)
	#ifndef __AVR__
	String yearanddate = String(year) + "," + String(::day(datetime)) + "-" + String(::month(datetime)) + "-" + String(::year(datetime));
	String liturgicalday = yearanddate + ",\"" + DayofWeek + "\",\"" + Class + "\",\"" + Colour + "\",\"" + Mass + "\",\"" + Commemoration + "\"\n";

	//printf("%4d,%02d-%02d-%4d,\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n", year, ::day(datetime), ::month(datetime), ::year(datetime), DayofWeek.c_str(), Class.c_str(), Colour.c_str(), Mass.c_str(), Commemoration.c_str());

	FILE* fp;
	fp = fopen("output.csv", "ab");
	//fprintf(fp, "%4d,%02d-%02d-%4d,\"%s\",\"%s\",\"%s\",\"%s\"\n", year, ::day(datetime), ::month(datetime), ::year(datetime), Class.c_str(), Colour.c_str(), Mass.c_str(), Commemoration.c_str());
	//fputs(liturgicalday.c_str(), fp);
	fwrite(liturgicalday.c_str(), 1, liturgicalday.length(), fp);
	fclose(fp);
	#endif
#endif
}

void Tridentine::GetMoveableFeast(time64_t datetime, bool doRogations, bool& is_feast, uint8_t& cls, uint8_t& col, bool& hdo, bool& feast_lord, bool& bCommemorationOnly, String& Mass, String& Commemoration) {
	int year = ::year(datetime);
	uint8_t season = Season(datetime);

	int feast = 0;
	int feast2 = 0; // The third minor rogation day falls on the same day as the Vigil of Ascension Thurday. It is the only time this happens. Displaying the Rogation Day in the Commemoration area on the screen will ensure both Masses are included
	bool comm = false;
	bool comm2 = false; // Ascension vigil/third rogation day clash resolution

	cls = 0; // holds the class for each feast
	hdo = sunday(datetime); // All Sundays are Holy Days of Obligation, plus certain weekday solemnities

	Commemoration = "";
	Mass = "";

	feast_lord = false;

	if (issameday(datetime, GaudeteSunday(year))) { feast = 1; cls = 1; }
	if (issameday(datetime, AdventEmbertide(year, 1))) { feast = 2; cls = 2; }
	if (issameday(datetime, AdventEmbertide(year, 2))) { feast = 3; cls = 2; }
	if (issameday(datetime, AdventEmbertide(year, 3))) { feast = 4; cls = 2; }
	if (issameday(datetime, SundayWithinTheOctaveOfXmas(year))) { feast = 5; cls = 2;  hdo = true; }
	if (issameday(datetime, HolyName(year))) { feast = 6; cls = 2; feast_lord = true; }
	if (issameday(datetime, HolyFamily(year))) { feast = 7; cls = 2; feast_lord = true; }
	if (issameday(datetime, PloughMonday(year))) { feast = 8; cls = 4; }
	if (issameday(datetime, AshWednesday(year))) { feast = 9; cls = 1;  hdo = true; }
	if (issameday(datetime, LentenEmbertide(year, 1))) { feast = 10; cls = 2; }
	if (issameday(datetime, LentenEmbertide(year, 2))) { feast = 11; cls = 2; }
	if (issameday(datetime, LentenEmbertide(year, 3))) { feast = 12; cls = 2; }
	if (issameday(datetime, Quinquagesima(year))) { feast = 13; cls = 2; }
	if (issameday(datetime, FatThursday(year))) { feast = 14; cls = 4; }
	if (issameday(datetime, ShroveMonday(year))) { feast = 15; cls = 3; }
	if (issameday(datetime, MardiGras(year))) { feast = 16; cls = 4; }
	
	if (issameday(datetime, StMatthias(year))) { 
		if (feast == 0 || cls > 2) {
			feast = 19; cls = 2;
		}
		else if (cls == 2) {
			feast2 = feast;
			comm2 = true;
			feast = 19;
		}
		else {
			feast2 = 19; 
			comm2 = true;
		}
	} // moved up before Sexagesima and Septuagesima so that these take precedence, should one of them fall on the same day as St Matthias (they are Sundays)
	
	if (issameday(datetime, Sexagesima(year))) { 
		feast = 17; cls = 2; 
		if (feast2 == 19) {
			comm2 = false;	// If Sexgesima falls on the same day as St Matthias, St Matthias is not celebrated.
		}
	}
	if (issameday(datetime, Septuagesima(year))) { feast = 18; cls = 2; }
	if (issameday(datetime, StGabrielOfOurLadyOfSorrows(year))) { feast = 20; cls = 3; }
	if (issameday(datetime, LaetareSunday(year))) { feast = 21; cls = 1; }
	if (issameday(datetime, PassionSunday(year))) { feast = 22; cls = 1; }
	if (issameday(datetime, SevenSorrows(year))) { feast = 23; cls = 3; comm = true; }
	if (issameday(datetime, LadyDay(year))) { feast = 24; cls = 1; }
	if (issameday(datetime, StJoseph(year))) { feast = 25; cls = 1; hdo = true; } // Class 1 feast of St Joseph is transferred to the following Monday if it falls on a Sunday, or Tuesday after Low Sunday if it falls in Holy Week
	if (issameday(datetime, PalmSunday(year))) { feast = 26; cls = 1; feast_lord = true; }
	if (issameday(datetime, MondayOfHolyWeek(year))) { feast = 27; cls = 1; }
	if (issameday(datetime, TuesdayOfHolyWeek(year))) { feast = 28; cls = 1; }
	if (issameday(datetime, SpyWednesday(year))) { feast = 29; cls = 1; }
	if (issameday(datetime, MaundyThursday(year))) { feast = 30; cls = 1; }
	if (issameday(datetime, GoodFriday(year))) { feast = 31; cls = 1; hdo = true; }
	if (issameday(datetime, HolySaturday(year))) { feast = 32; cls = 1; }
	if (issameday(datetime, Easter(year))) { feast = 33; cls = 1; feast_lord = true; }
	if (issameday(datetime, EasterMonday(year))) { feast = 34; cls = 1; }
	if (issameday(datetime, EasterTuesday(year))) { feast = 35; cls = 1; }
	if (issameday(datetime, EasterWednesday(year))) { feast = 36; cls = 1; }
	if (issameday(datetime, EasterThursday(year))) { feast = 37; cls = 1; }
	if (issameday(datetime, EasterFriday(year))) { feast = 38; cls = 1; }
	if (issameday(datetime, EasterSaturday(year))) { feast = 39; cls = 1; }
	if (issameday(datetime, QuasimodoSunday(year))) { feast = 40; cls = 1; }
	if (issameday(datetime, MisericordiaSunday(year))) { feast = 41; cls = 2; }
	if (issameday(datetime, JubilateSunday(year))) { feast = 42; cls = 2; }
	if (issameday(datetime, CantateSunday(year))) { feast = 43; cls = 2; }
	
	if (doRogations) {
		if (issameday(datetime, MajorRogation(year))) { feast = 44; cls = 2; } // not sure if class = 2? made same as minor rogations
		if (issameday(datetime, MinorRogation(year, 1))) { feast = 45; cls = 2; }
		if (issameday(datetime, MinorRogation(year, 2))) { feast = 46; cls = 2; }
		if (issameday(datetime, MinorRogation(year, 3))) { feast = 47; cls = 2; } // the third minor rogation day is the same day as the vigil of the Ascension (ie, one day before Ascension Thursday)
		if (issameday(datetime, AscensionVigil(year))) { feast2 = 48; cls = 2; comm2 = true; }
	}
	else {
		if (issameday(datetime, AscensionVigil(year))) { feast = 48; cls = 2; }
	}

	if (issameday(datetime, Ascension(year))) { feast = 49; cls = 1; hdo = true; feast_lord = true; }
	if (issameday(datetime, SundayAfterAscension(year))) { feast = 50; cls = 2; }
	if (issameday(datetime, PentecostVigil(year))) { feast = 51; cls = 1; }
	if (issameday(datetime, Pentecost(year))) { feast = 52; cls = 1; feast_lord = true; }
	if (issameday(datetime, PentecostMonday(year))) { feast = 53; cls = 1; }
	if (issameday(datetime, PentecostTuesday(year))) { feast = 54; cls = 1; }
	if (issameday(datetime, WhitEmbertide(year, 1))) { feast = 55; cls = 1; }
	if (issameday(datetime, WhitEmbertide(year, 2))) { feast = 56; cls = 1; }
	if (issameday(datetime, WhitEmbertide(year, 3))) { feast = 57; cls = 1; }
	if (issameday(datetime, ThursdayInPentecostWeek(year))) { feast = 58; cls = 1; }
	if (issameday(datetime, TrinitySunday(year))) { feast = 59; cls = 1; feast_lord = true; }
	if (issameday(datetime, CorpusChristi(year))) { feast = 60; cls = 1; hdo = true; feast_lord = true; }
	if (issameday(datetime, SacredHeart(year))) { feast = 61; cls = 1; hdo = true; feast_lord = true; }
	if (issameday(datetime, PetersPence(year))) { feast = 62; cls = 2; }
	if (issameday(datetime, MichaelmasEmbertide(year, 1))) { feast = 63; cls = 2; }
	if (issameday(datetime, MichaelmasEmbertide(year, 2))) { feast = 64; cls = 2; }
	if (issameday(datetime, MichaelmasEmbertide(year, 3))) { feast = 65; cls = 2; }
	if (issameday(datetime, AllSouls(year))) { feast = 66; cls = 1; }
	if (issameday(datetime, ChristTheKing(year))) { feast = 67; cls = 1; feast_lord = true; }

	Yml i18n;

	// Handle moveable feasts and default feria
	if (feast > 0) {
		is_feast = true;

		String yml_path = String(F("tridentine.solemnity.")) + String(FPSTR(Feasts[feast]));
		if (!comm) {
			Mass = i18n.get(yml_path);
		}
		else {
			Commemoration = i18n.get(yml_path);
			bCommemorationOnly = true;
		}

		if (feast2 > 0) { // handle Ascension Vigil/Third minor rogation day clash by making the Vigil a commemoration
			if (comm2) {
				Commemoration = i18n.get(String(F("tridentine.solemnity.")) + String(FPSTR(Feasts[feast2])));
			}
		}
	}
}

void Tridentine::GetFixedFeast(time64_t datetime, bool& is_feast, uint8_t& cls, uint8_t& col, bool& hdo, bool& feast_lord, bool& immaculate_conception, bool& bCommemorationOnly, String& Mass, String& Commemoration) {
	Yml i18n;
	Tr_Fixed_Feast trff;

	i18n.get_fixed_feast(datetime, trff);

	is_feast = trff.IsFeast;

	if (trff.IsFeast) {
		cls = trff.Class;
		col = trff.Colour;
		bCommemorationOnly = trff.bMassIsCommemoration;
		if (trff.bHasCommemoration) {
			Commemoration = trff.Commemoration;
		}
		if (trff.bMassIsCommemoration) {
			Commemoration = trff.Mass;
		}
		else {
			Mass = trff.Mass;
		}
		
		feast_lord = trff.Feast_Of_The_Lord;
		immaculate_conception = trff.ImmaculateConception;
		hdo = trff.Holy_Day_Of_Obligation;
	}
}

void Tridentine::GetVotiveMass(time64_t datetime, bool& is_votive, uint8_t& cls, uint8_t& col, String& Mass, String& Commemoration) {
	HandleVotiveMasses(datetime, is_votive, cls, col, Mass, Commemoration);
}

//void Tridentine::GetDay(time64_t datetime, String& Mass){
//
//}

///////////////////////////////////
// Functions for reading the texts
bool Tridentine::getHeaderRecord(File& file, IndexHeader& ih) {
	//ih = {0};
	
	if (file && file.available()) {
		//int filepos = file.position();

		file.seek(0); // header is at start of index file
		
		Csv csv;
		bool bFileOk = true;
		String headers = Yml::readLine(file, bFileOk);
		DEBUG_PRT.print(F("getHeaderRecord() ["));
		DEBUG_PRT.print(headers);
		DEBUG_PRT.println(F("]"));

		if (bFileOk) {
			int pos = 0;
			ih.heading = csv.getCsvField(headers, &pos);
			ih.name = csv.getCsvField(headers, &pos);
			ih.commemoration = csv.getCsvField(headers, &pos);
			ih.cls  = csv.getCsvField(headers, &pos);
			ih.colour  = csv.getCsvField(headers, &pos);

			DumpIndexHeader(ih);
			//file.seek(filepos); // restore original filepos (if needed?)

			return true;
		}
	}
	DEBUG_PRT.print(F("getHeaderRecord() File is not available, free mem="));
	DEBUG_PRT.println(String(system_get_free_heap_size()));
	return false;
}

bool Tridentine::getIndexRecord(File& file, IndexRecord& ir) {	// gets the index record at file.position()
	//ir = {0};

	if (file && file.available()) {

		Csv csv;
		bool bFileOk = true;
		String indexrecord = Yml::readLine(file, bFileOk);
		int filepos = file.position();

		DEBUG_PRT.print(F("getIndexRecord() ["));
		DEBUG_PRT.print(indexrecord);
		DEBUG_PRT.println(F("]"));

		if (bFileOk) {
			int pos = 0;
			ir.heading = csv.getCsvField(indexrecord, &pos);
			ir.filenumber = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.filecount = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.partnumber  = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.partcount  = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.fileoffset_start = csv.getCsvField(indexrecord, &pos).toInt();
			ir.fileoffset_end = csv.getCsvField(indexrecord, &pos).toInt();

			DumpIndexRecord(ir);

//			// now need to read the next record and retrieve only the fileoffset__start value, which becomes the fileoffset_end value of the
//			// record we want.
//
//			if (file.available()) {
//				String nextindexrecord = Yml::readLine(file, bFileOk);
//				if (bFileOk) {
//					pos = 0;
//					for (int8_t i = 0; i < 5; i++) {
//						csv.getCsvField(indexrecord, &pos);	// skip over unwanted records in csv line, only want the last one
//					}
//					ir.fileoffset_end = csv.getCsvField(indexrecord, &pos).toInt();
//				}
//			}
//
//			file.seek(filepos); // restore original filepos which should be end of record n (ie start of record n+1, where we got the fileoffset_end value)

			return true;
		}
	}
	DEBUG_PRT.print("getIndexRecord() File is not available, free mem=");
	DEBUG_PRT.println(String(system_get_free_heap_size()));
	return false;
}

uint8_t Tridentine::getClassIndex(String cls, bool bUseNewClasses) {
	/// TODO: PLL-12-01-2021 Need to handle first two Sundays of Advent (Semiduplex II. classis) and Semiduplex Dominica minor, eg. 20th Sunday after Pentecost
	
	// problem: if (say) Duplex I. classis is passed in, how to avoid matching Duplex with (Duplex I. Classis).indexOf("Duplex")

	DEBUG_PRT.print(F("\ngetClassIndex() cls =["));
	DEBUG_PRT.print(cls);
	DEBUG_PRT.print(F("], bUseNewClasses="));
	DEBUG_PRT.println(bUseNewClasses);

	const char* const tradtable[7] = {
        "none", 
		"Simplex", 
		"Semiduplex", 
		"Duplex",
        "Duplex majus", 
		"Duplex II. classis", 
		"Duplex I. classis" //, 
		//"Duplex I. classis"
	};
    
	const char* const newtable[7] = {
        "none",
        "Commemoratio",
        "III. classis",
        "III. classis",
        "III. classis",
        "II. classis",
        "I. classis" //,
        //"I. classis"
	};

	uint8_t foundlast = 0; // tradtable: String such as Duplex I. classis will contain both Duplex and Duplex I.classis, so will match the wrong class value in this case
						   // taking the *last* matched value will solve this *for this application and set of strings*
	uint8_t foundfirst = 0; // newtable: Strings such as I. classis will be found in I. classis, II. classis and III. classis. So for this case, need to take the *first*
							// matched value will solve this for this set of strings.

	for (uint8_t i = 0; i < 7; i++) {
		//if (cls == String(tradtable[i]) || cls == String(newtable[i])) return i;
		if ((!bUseNewClasses && cls.indexOf(tradtable[i]) != -1) || (bUseNewClasses && cls.indexOf(newtable[i]) != -1))  {
			if (foundfirst == 0) foundfirst = i;
			foundlast = i;
			DEBUG_PRT.printf("getClassIndex() i=%d, indexOf: classtable[i]=%d\n", i, bUseNewClasses ? cls.indexOf(newtable[i]) : cls.indexOf(tradtable[i]));
		}
		//return i; // PLL-05-04-2021 Check if class string is present in passed string, rather than an exact match, due to possibilities such as "Dies Octavæ I. classis"
					// (in newtable[]) being passed to function
	}
	
	return bUseNewClasses ? foundfirst : foundlast;
	//return 0;
}

bool Tridentine::getText(File& file, IndexRecord& indexrecord, String& s, bool& bFileOk, bool& bMoreText) {
	bMoreText = false;
	bool bTextAvailable = (file.position() < indexrecord.fileoffset_end);
	if (indexrecord.fileoffset_end == -1) {
		bTextAvailable = (indexrecord.fileoffset_end < file.size());
	}

	DEBUG_PRT.print(F("getText() file.position="));
	DEBUG_PRT.print(file.position());
	DEBUG_PRT.print(F(", indexrecord.fileoffset_start="));
	DEBUG_PRT.print(indexrecord.fileoffset_start);
	DEBUG_PRT.print(F(", indexrecord.fileoffset_end="));
	DEBUG_PRT.print(indexrecord.fileoffset_end);
	DEBUG_PRT.print(F(", bTextAvailable="));
	DEBUG_PRT.println(bTextAvailable);

	if (bTextAvailable) {
		s = Yml::readLine(file, bFileOk, indexrecord.fileoffset_end);
		
		bMoreText = (file.position() < indexrecord.fileoffset_end);
		if (indexrecord.fileoffset_end == -1) {
			bMoreText = (indexrecord.fileoffset_end < file.size());
		}

		DEBUG_PRT.print(F("Text is ["));
		DEBUG_PRT.print(s);
		DEBUG_PRT.print(F("]\nbMoreText = "));
		DEBUG_PRT.println(bMoreText);
	}

	return bTextAvailable;	// shows if this call returned some text
}

void Tridentine::DumpIndexHeader(IndexHeader& ih) {
	DEBUG_PRT.println(ih.heading);
	DEBUG_PRT.println(ih.name);
	DEBUG_PRT.println(ih.commemoration);
	DEBUG_PRT.println(ih.cls);
	DEBUG_PRT.println(ih.colour);
}

void Tridentine::DumpIndexRecord(IndexRecord& ir) {
	DEBUG_PRT.println(ir.heading);
	DEBUG_PRT.println(ir.filenumber);
	DEBUG_PRT.println(ir.filecount);
	DEBUG_PRT.println(ir.partnumber);
	DEBUG_PRT.println(ir.partcount);
	DEBUG_PRT.println(ir.fileoffset_start);
	DEBUG_PRT.println(ir.fileoffset_end);
}



//// Missal Reading class
MissalReading::MissalReading() {
}

bool MissalReading::open(String filedir, String fileroot) {
	DEBUG_PRT.print(F("MissalReading::open() filedir="));
	
	filecount = -1;
	partcount = -1;
	curr_subpartlen = -1;

	if (!filedir.endsWith("/")) {
		filedir += "/";
	}

	if (fileroot != "" && !fileroot.endsWith("/")) {
		fileroot += "/";
	}

	DEBUG_PRT.print(fileroot + filedir);
	DEBUG_PRT.print(F(": "));

	String indexfilename = fileroot + filedir + "index.txt";
  	String propersfilename = fileroot + filedir + "propers.txt";

    _fpindex = SD.open(indexfilename, FILE_READ);
    if (!_fpindex.available()) {
      DEBUG_PRT.println(F("Couldn't open index file"));
	  return false;
    }
    
	_fppropers = SD.open(propersfilename, FILE_READ);
    if (!_fppropers.available()) {
      DEBUG_PRT.println(F("Couldn't open propers file"));
	  return false;
    }

	if (!getHeaderRecord(_fpindex, _ih)) {
	    DEBUG_PRT.println(F("Couldn't read index header"));
		return false;
	}

	if (!getIndexRecord(_fpindex, _ir)) {
	    DEBUG_PRT.println(F("Couldn't read first header record"));
		return false;
	}
	else {
		filecount = _ir.filecount;
		partcount = _ir.partcount;
		curr_subpartlen = _ir.fileoffset_end - _ir.fileoffset_start;
	}

	DEBUG_PRT.println(F("ok"));
	
	_open = true;
	_filedir = filedir;

	patchHolyFamily1570();
	patchDiesJanuarii1955(fileroot);
	patchOctaveDayofAscension();
	return true;
}

bool MissalReading::get(int8_t& ir_part, int8_t& ir_subpart, String& text, bool& bMoreText) {
	bool bResetPropersFilePtr = false;
	return get(ir_part, ir_subpart, text, bMoreText, bResetPropersFilePtr);
}

// get a line of text from the propers files. Continue reading text under currently selected heading line by line, 
// or skip to next subpart (if any), or return false if text (in all subparts) under heading is exhausted
bool MissalReading::get(int8_t& ir_part, int8_t& ir_subpart, String& text, bool& bMoreText, bool& bResetPropersFilePtr) {
/*
	if (!_fpindex.available()) {
		DEBUG_PRT.println(F("MissalReading::get(): index file is not open"));
		return false;
	}

	if (!_fppropers.available()) {
		DEBUG_PRT.println(F("MissalReading::get(): propers file is not open"));
		return false;
	}
*/

	bMoreText = false; // PLL-30-03-2021

	if (!_open) {
		DEBUG_PRT.println(F("MissalReading::get(): MissalReading object is not open - call open() first"));
		return false;
	}

	bool bIndexAvailable = true;

	if (bResetPropersFilePtr || !(ir_part == _ir.filenumber && ir_subpart == _ir.partnumber)) {
		bIndexAvailable = getIndex(ir_part, ir_subpart);
		bResetPropersFilePtr = false;
	}

	if (bIndexAvailable) {
		bool bFileOk = true;
		bMoreText = true;
		bool bTextAvailable = getText(_fppropers, _ir, text, bFileOk, bMoreText);

		if (!bMoreText && _ir.partnumber < _ir.partcount - 1) { // PLL-31-03-2021 If there is no more text for this part (of a multipart record)
			bMoreText = true; 									// PLL-31-03-2021 and it is not the last subpart, then there is more text, so set bMoreText.
		}

		if (!bTextAvailable && _ir.partnumber < _ir.partcount - 1) {
			DEBUG_PRT.println(F("MissalReading::get(): More subparts found, getting index for next subpart"));
			ir_subpart++;
			if (!getIndex(ir_part, ir_subpart)) {
				DEBUG_PRT.println(F("MissalReading::get(): Couldn't get index for next subpart"));
				return false;
			}

			bTextAvailable = getText(_fppropers, _ir, text, bFileOk, bMoreText);

			if (!bMoreText && _ir.partnumber < _ir.partcount - 1) { // PLL-31-03-2021 If there is no more text for this part (of a multipart record)
				bMoreText = true; 									// PLL-31-03-2021 and it is not the last subpart, then there is more text, so set bMoreText.
			}

			DEBUG_PRT.print(F("\nMissalReading::get(): new subpart: bMoreText = "));
			DEBUG_PRT.println(bMoreText);
			DEBUG_PRT.print(F("MissalReading::get(): bTextAvailable = "));
			DEBUG_PRT.println(bTextAvailable);
			return true;
		}
		else {
			DEBUG_PRT.print(F("\nMissalReading::get(): part or subpart: bMoreText = "));
			DEBUG_PRT.println(bMoreText);
		}
		
		DEBUG_PRT.print(F("MissalReading::get(): bTextAvailable = "));
		DEBUG_PRT.println(bTextAvailable);
		return bTextAvailable;
	}

	DEBUG_PRT.println(F("MissalReading::get(): index is not available for requested part and subpart"));
	return false;

}

bool MissalReading::getIndex(int8_t& ir_part, int8_t& ir_subpart, bool bResetIndexFilePtr) {
	DEBUG_PRT.print(F("MissalReading::getindex(): Looking for index record part "));
	DEBUG_PRT.print(ir_part);
	DEBUG_PRT.print(F(", subpart "));
	DEBUG_PRT.println(ir_subpart);

	if (!_fpindex.available()) {
		DEBUG_PRT.println(F("MissalReading::getindex(): Index file is not available"));
		return false;
	}

	if (bResetIndexFilePtr) {
		_fpindex.seek(0);
	}

	if (getHeaderRecord(_fpindex, _ih)) {
		bool bFoundIndexRecord = false;
		bool bIndexRecordPossible = true;

		while (_fpindex.available() && !bFoundIndexRecord && bIndexRecordPossible && getIndexRecord(_fpindex, _ir)) {

			// PLL-29-10-2021
			// nasty hack to take care of the fact that I counted the actual number of "files" in the filecount (that is, 1 for each group of subparts), 
			// but skipped the file index 3 when dealing with the 1570 Mass (which has no part 3, Lectio) - so the filecount for this Mass's propers 
			// is 11 rather than 12, although the maximum part index can also be 11 in this case, which breaks the ir_part >= _ir.filecount comparison (below) for the 1570 Mass
			if (_ir.filecount == 11 && ir_part == 11) _ir.filecount = 12;
			//
			// Did the same thing for the Good Friday propers, which have six parts, but the number for _ir.filecount is 5
			if (_ir.filecount == 5 && ir_part == 5) _ir.filecount = 6;

			if (ir_part >= _ir.filecount || _ir.filenumber > ir_part || (_ir.filenumber == ir_part && ir_subpart >= _ir.partcount)) {
				bIndexRecordPossible = false;	// can't be present if so
			}

			if (_ir.filenumber == ir_part && _ir.partnumber == ir_subpart) {
				bFoundIndexRecord = true;
				_fppropers.seek(_ir.fileoffset_start);
			}
		}
		
		if (bFoundIndexRecord) {
			DEBUG_PRT.println(F("MissalReading::getindex(): Found index record"));
			filecount = _ir.filecount;
			partcount = _ir.partcount;
			curr_subpartlen = _ir.fileoffset_end - _ir.fileoffset_start;
		}
		else {
			DEBUG_PRT.println(F("MissalReading::getindex(): Index record not found"));
			filecount = -1;
			partcount = -1;
			curr_subpartlen = -1;			
		}

		return bFoundIndexRecord;
	}

	DEBUG_PRT.println(F("MissalReading::getindex(): No index header"));
	return false;
}

void MissalReading::close() {
	DEBUG_PRT.println(F("MissalReading::close()"));
	_fpindex.close();
	_fppropers.close();
	_open = false;
	_filedir = "";

	filecount = -1;
	partcount = -1;
    curr_subpartlen = -1;
}

bool MissalReading::isOpen() {
	return _open;
}


///////////////////////////////////
// Functions for reading the texts
bool MissalReading::getHeaderRecord(File& file, IndexHeader& ih) {
	//ih = {0};
	
	if (file && file.available()) {
		//int filepos = file.position();

		file.seek(0); // header is at start of index file
		
		Csv csv;
		bool bFileOk = true;
		String headers = Yml::readLine(file, bFileOk);
		DEBUG_PRT.print(F("getHeaderRecord() ["));
		DEBUG_PRT.print(headers);
		DEBUG_PRT.println(F("]"));

		if (bFileOk) {
			int pos = 0;
			ih.heading = csv.getCsvField(headers, &pos);
			ih.name = csv.getCsvField(headers, &pos);
			ih.commemoration = csv.getCsvField(headers, &pos);
			ih.cls  = csv.getCsvField(headers, &pos);
			ih.colour  = csv.getCsvField(headers, &pos);

			int ci = ih.commemoration.indexOf(": ");	// Our Lady of Mount Carmel commemoration heading has a rogue ':' at the beginning. Remove it if found.
			if (ih.name == "" && ci == 0) {
				ih.commemoration = ih.commemoration.substring(ci + 2);
			}

			DumpIndexHeader(ih);
			//file.seek(filepos); // restore original filepos (if needed?)

			return true;
		}
	}

	DEBUG_PRT.print(F("getHeaderRecord() File is not available, free mem="));
	DEBUG_PRT.println(String(system_get_free_heap_size()));
	return false;
}

void MissalReading::patchHolyFamily1570() {
	// patch for problem with Tridentine 1570AD Holy Family feast record (which is not a feast in this calendar, but the Sunday within the Octave of Pentecost)
	// It is missing the Class and Name fields, but they are contained within the Heading string
	if (isOpen()) {
		if (_ih.name == "" && _ih.commemoration == "") {
			_ih.name = _ih.heading.substring(0, _ih.heading.indexOf("  "));
			_ih.cls = _ih.heading.substring(_ih.heading.indexOf("  ") + 2);
		}
	}
}

void MissalReading::patchDiesJanuarii1955(String& filedir) {
	if (isOpen() && filedir.indexOf("1955") != -1 && _ih.name.indexOf("Januarii") != -1 && _ih.name.indexOf("Episcopi") == -1) {	// avoid including St. Januarii! (19th Sept)
		_ih.cls = F("Feria");
	}
}

void MissalReading::patchOctaveDayofAscension() {
	if (isOpen() && _ih.name.indexOf("Feria V in Octava Ascensionis") != -1) {
		_ih.name = F("Octavæ Ascensionis");
	}
}

void MissalReading::setClass(String class_name) {
	_ih.cls = class_name;
}

String MissalReading::heading(bool b_commemoration) {
	if (b_commemoration) {
		return _ih.commemoration;
	}
	return _ih.heading;
}

String MissalReading::name(bool b_commemoration) {
	if (b_commemoration) {
		return _ih.commemoration;
	}
	
	/*	if (_ih.commemoration != "") {
		return _ih.commemoration;		// PLL-17-04-2021 when asked for name(), return the name of the commemoration if it is present (is blank for non-commemorations)
	}
*/	
	return _ih.name;
}

bool MissalReading::isCommemorationOnly() {
	return (name() == "");
}

String MissalReading::commemoration() {
	return _ih.commemoration;
}

String MissalReading::cls() {
	DEBUG_PRT.print("cls():");
	DEBUG_PRT.println(_ih.cls);

	return _ih.cls;
}

String MissalReading::colour() {
	return _ih.colour;
}

bool MissalReading::getIndexRecord(File& file, IndexRecord& ir) {	// gets the index record at file.position()
	//ir = {0};

	if (file && file.available()) {

		Csv csv;
		bool bFileOk = true;
		String indexrecord = Yml::readLine(file, bFileOk);
		int filepos = file.position();

		DEBUG_PRT.print(F("getIndexRecord() ["));
		DEBUG_PRT.print(indexrecord);
		DEBUG_PRT.println(F("]"));

		if (bFileOk) {
			int pos = 0;
			ir.heading = csv.getCsvField(indexrecord, &pos);
			ir.filenumber = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.filecount = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.partnumber  = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.partcount  = (int8_t)csv.getCsvField(indexrecord, &pos).toInt();
			ir.fileoffset_start = csv.getCsvField(indexrecord, &pos).toInt();
			ir.fileoffset_end = csv.getCsvField(indexrecord, &pos).toInt();

			DumpIndexRecord(ir);

			return true;
		}
	}
	DEBUG_PRT.print("getIndexRecord() File is not available, free mem=");
	DEBUG_PRT.println(String(system_get_free_heap_size()));
	return false;
}


bool MissalReading::getText(File& file, IndexRecord& indexrecord, String& s, bool& bFileOk, bool& bMoreText) {
	bMoreText = false;
	bool bTextAvailable = (file.position() < indexrecord.fileoffset_end);
	if (indexrecord.fileoffset_end == -1) {
		bTextAvailable = (indexrecord.fileoffset_end < file.size());
	}

	DEBUG_PRT.print(F("getText() file.position="));
	DEBUG_PRT.print(file.position());
	DEBUG_PRT.print(F(", indexrecord.fileoffset_start="));
	DEBUG_PRT.print(indexrecord.fileoffset_start);
	DEBUG_PRT.print(F(", indexrecord.fileoffset_end="));
	DEBUG_PRT.print(indexrecord.fileoffset_end);
	DEBUG_PRT.print(F(", bTextAvailable="));
	DEBUG_PRT.println(bTextAvailable);

	if (bTextAvailable) {
		s = Yml::readLine(file, bFileOk, indexrecord.fileoffset_end);
		
		bMoreText = (file.position() < indexrecord.fileoffset_end);
		if (indexrecord.fileoffset_end == -1) {
			bMoreText = (indexrecord.fileoffset_end < file.size());
		}

		DEBUG_PRT.print(F("Text is ["));
		DEBUG_PRT.print(s);
		DEBUG_PRT.print(F("]\nbMoreText = "));
		DEBUG_PRT.println(bMoreText);
	}

	return bTextAvailable;	// shows if this call returned some text
}

void MissalReading::DumpIndexHeader(IndexHeader& ih) {
	DEBUG_PRT.println(ih.heading);
	DEBUG_PRT.println(ih.name);
	DEBUG_PRT.println(ih.commemoration);
	DEBUG_PRT.println(ih.cls);
	DEBUG_PRT.println(ih.colour);
}

void MissalReading::DumpIndexRecord(IndexRecord& ir) {
	DEBUG_PRT.println(ir.heading);
	DEBUG_PRT.println(ir.filenumber);
	DEBUG_PRT.println(ir.filecount);
	DEBUG_PRT.println(ir.partnumber);
	DEBUG_PRT.println(ir.partcount);
	DEBUG_PRT.println(ir.fileoffset_start);
	DEBUG_PRT.println(ir.fileoffset_end);
}
